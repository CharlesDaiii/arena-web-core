{"version":3,"sources":["aframe-mods.js"],"names":["CLAMP_VELOCITY","MAX_DELTA","AFRAME","components","Component","prototype","updateVelocity","delta","adSign","data","keys","velocity","wsSign","adAxis","wsAxis","scaledEasing","Math","pow","easing","abs","enabled","acceleration","adEnabled","adInverted","KeyA","KeyD","wsEnabled","wsInverted","KeyW","ArrowUp","KeyS","ArrowDown","MAX_DELTA_LOOK","keysPressed","registerComponent","init","attachKeyEventListeners","window","addEventListener","onKeyDown","onKeyUp","removeKeyEventListeners","removeEventListener","event","key","tick","time","ARENA","sceneObjects","myCamera","lookControls","yawObject","rotation","y","update","self","el","src","remove","loader","load","gltfModel","model","scene","scenes","animations","setObject3D","emit","format","xhr","progress","loaded","total","error","message","console"],"mappings":";AAUA,MAAMA,EAAiB,KACjBC,EAAY,GAClBC,OAAOC,WAAW,iBAAiBC,UAAUC,UAAUC,eAAiB,SAASC,GACzEC,IAAAA,EACEC,MAAAA,EAAO,KAAKA,KACZC,EAAO,KAAKA,KACZC,EAAW,KAAKA,SAClBC,IAAAA,EAEEC,MAAAA,EAASJ,EAAKI,OACdC,EAASL,EAAKK,OAGhBP,GAAAA,EAZU,GAeV,OAFAI,EAASE,GAAU,OACnBF,EAASG,GAAU,GAKjBC,MAAAA,EAAeC,KAAKC,IAAI,EAAI,KAAKC,OAAgB,GAARX,GAiB3C,GAfqB,IAArBI,EAASE,KACTF,EAASE,GAAUF,EAASE,GAAUE,GAEjB,IAArBJ,EAASG,KACTH,EAASG,GAAUH,EAASG,GAAUC,GAItCC,KAAKG,IAAIR,EAASE,IA9BH,OA+BfF,EAASE,GAAU,GAEnBG,KAAKG,IAAIR,EAASG,IAjCH,OAkCfH,EAASG,GAAU,IAGlBL,EAAKW,QACN,OAIEC,MAAAA,EAAeZ,EAAKY,aACtBZ,EAAKa,YACLd,EAASC,EAAKc,YAAc,EAAI,EAC5Bb,EAAKc,OACLb,EAASE,IAAWL,EAASa,EAAed,GAE5CG,EAAKe,OACLd,EAASE,IAAWL,EAASa,EAAed,IAGhDE,EAAKiB,YACLd,EAASH,EAAKkB,YAAc,EAAI,GAC5BjB,EAAKkB,MAAQlB,EAAKmB,WAClBlB,EAASG,IAAWF,EAASS,EAAed,IAE5CG,EAAKoB,MAAQpB,EAAKqB,aAClBpB,EAASG,IAAWF,EAASS,EAAed,KAKxD,MAAMyB,EAAiB,KAEvBC,YAAc,GAEd/B,OAAOgC,kBAAkB,sBAAuB,CAC5CC,KAAM,WACGC,KAAAA,2BAGTA,wBAAyB,WACrBC,OAAOC,iBAAiB,UAAW,KAAKC,WACxCF,OAAOC,iBAAiB,QAAS,KAAKE,UAG1CC,wBAAyB,WACrBJ,OAAOK,oBAAoB,UAAW,KAAKH,WAC3CF,OAAOK,oBAAoB,QAAS,KAAKF,UAG7CD,UAAW,SAASI,GAChBV,YAAYU,EAAMC,MAAO,GAG7BJ,QAAS,SAASG,UACPV,YAAYU,EAAMC,MAG7BC,KAAM,SAASC,EAAMvC,GACb,IAACwC,QAAUA,MAAMC,aAAaC,SAAU,OACtCA,MACAC,EADWH,MAAMC,aAAaC,SACN9C,WAAW,iBAEnCO,EAAOuB,YACTvB,EAAI,YACJwC,EAAaC,UAAUC,SAASC,GAlCrB,MAoCX3C,EAAI,aACJwC,EAAaC,UAAUC,SAASC,GArCrB,SAmDvBnD,OAAOC,WAAW,cAAcC,UAAUC,UAAUiD,OAAS,WACnDC,MAAAA,EAAO,KACPC,EAAK,KAAKA,GACVC,EAAM,KAAKhD,KAEZgD,IAIAC,KAAAA,SAEAC,KAAAA,OAAOC,KAAKH,EAAK,SAAoBI,GACtCN,EAAKO,MAAQD,EAAUE,OAASF,EAAUG,OAAO,GACjDT,EAAKO,MAAMG,WAAaJ,EAAUI,WAClCT,EAAGU,YAAY,OAAQX,EAAKO,OAC5BN,EAAGW,KAAK,eAAgB,CAACC,OAAQ,OAAQN,MAAOP,EAAKO,SACtD,SAAsBO,GACrBb,EAAGW,KAAK,iBAAkB,CAACV,IAAKA,EAAKa,SAAWD,EAAIE,OAASF,EAAIG,MAAQ,OAC1E,SAAoBC,GACbC,MAAAA,EAAWD,GAASA,EAAMC,QAAWD,EAAMC,QAAU,4BAC3DC,QAAQF,MAAMC,GACdlB,EAAGW,KAAK,cAAe,CAACC,OAAQ,OAAQX,IAAKA","file":"aframe-mods.ea80ee39.js","sourceRoot":"../src","sourcesContent":["/**\n * @fileoverview Direct modifications to AFRAME components to improve UX in the ARENA\n *\n * Open source software under the terms in /LICENSE\n * Copyright (c) 2020, The CONIX Research Center. All rights reserved.\n * @date 2020\n */\n\n/* global AFRAME, ARENA */\n\nconst CLAMP_VELOCITY = 0.00001;\nconst MAX_DELTA = 0.2;\nAFRAME.components['wasd-controls'].Component.prototype.updateVelocity = function(delta) {\n    let adSign;\n    const data = this.data;\n    const keys = this.keys;\n    const velocity = this.velocity;\n    let wsSign;\n\n    const adAxis = data.adAxis;\n    const wsAxis = data.wsAxis;\n\n    // If FPS too low, reset velocity.\n    if (delta > MAX_DELTA) {\n        velocity[adAxis] = 0;\n        velocity[wsAxis] = 0;\n        return;\n    }\n\n    // https://gamedev.stackexchange.com/questions/151383/frame-rate-independant-movement-with-acceleration\n    const scaledEasing = Math.pow(1 / this.easing, delta * 60);\n    // Velocity Easing.\n    if (velocity[adAxis] !== 0) {\n        velocity[adAxis] = velocity[adAxis] * scaledEasing;\n    }\n    if (velocity[wsAxis] !== 0) {\n        velocity[wsAxis] = velocity[wsAxis] * scaledEasing;\n    }\n\n    // Clamp velocity easing.\n    if (Math.abs(velocity[adAxis]) < CLAMP_VELOCITY) {\n        velocity[adAxis] = 0;\n    }\n    if (Math.abs(velocity[wsAxis]) < CLAMP_VELOCITY) {\n        velocity[wsAxis] = 0;\n    }\n\n    if (!data.enabled) {\n        return;\n    }\n\n    // Update velocity using keys pressed.\n    const acceleration = data.acceleration;\n    if (data.adEnabled) {\n        adSign = data.adInverted ? -1 : 1;\n        if (keys.KeyA) {\n            velocity[adAxis] -= adSign * acceleration * delta;\n        }\n        if (keys.KeyD) {\n            velocity[adAxis] += adSign * acceleration * delta;\n        }\n    }\n    if (data.wsEnabled) {\n        wsSign = data.wsInverted ? -1 : 1;\n        if (keys.KeyW || keys.ArrowUp) {\n            velocity[wsAxis] -= wsSign * acceleration * delta;\n        }\n        if (keys.KeyS || keys.ArrowDown) {\n            velocity[wsAxis] += wsSign * acceleration * delta;\n        }\n    }\n};\n\nconst MAX_DELTA_LOOK = 0.015;\n// const PI_2 = Math.PI / 2;\nkeysPressed = {};\n\nAFRAME.registerComponent('look-controls-arrow', {\n    init: function() {\n        this.attachKeyEventListeners();\n    },\n\n    attachKeyEventListeners: function() {\n        window.addEventListener('keydown', this.onKeyDown);\n        window.addEventListener('keyup', this.onKeyUp);\n    },\n\n    removeKeyEventListeners: function() {\n        window.removeEventListener('keydown', this.onKeyDown);\n        window.removeEventListener('keyup', this.onKeyUp);\n    },\n\n    onKeyDown: function(event) {\n        keysPressed[event.key] = true;\n    },\n\n    onKeyUp: function(event) {\n        delete keysPressed[event.key];\n    },\n\n    tick: function(time, delta) {\n        if (!ARENA || !ARENA.sceneObjects.myCamera) return;\n        const myCamera = ARENA.sceneObjects.myCamera;\n        const lookControls = myCamera.components['look-controls'];\n\n        const keys = keysPressed;\n        if (keys['ArrowLeft']) {\n            lookControls.yawObject.rotation.y += MAX_DELTA_LOOK;\n        }\n        if (keys['ArrowRight']) {\n            lookControls.yawObject.rotation.y -= MAX_DELTA_LOOK;\n        }\n\n        // if (keys['ArrowUp']) {\n        //    lookControls.pitchObject.rotation.x += MAX_DELTA_LOOK;\n        // }\n        // if (keys['ArrowDown']) {\n        // lookControls.pitchObject.rotation.x -= MAX_DELTA_LOOK;\n        // }\n        // lookControls.pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, lookControls.pitchObject.rotation.x));\n    },\n});\n\n// emit model onProgress (loading) event for gltf models\nAFRAME.components['gltf-model'].Component.prototype.update = function() {\n    const self = this;\n    const el = this.el;\n    const src = this.data;\n\n    if (!src) {\n        return;\n    }\n\n    this.remove();\n\n    this.loader.load(src, function gltfLoaded(gltfModel) {\n        self.model = gltfModel.scene || gltfModel.scenes[0];\n        self.model.animations = gltfModel.animations;\n        el.setObject3D('mesh', self.model);\n        el.emit('model-loaded', {format: 'gltf', model: self.model});\n    }, function gltfProgress(xhr) {\n        el.emit('model-progress', {src: src, progress: (xhr.loaded / xhr.total * 100)});\n    }, function gltfFailed(error) {\n        const message = (error && error.message) ? error.message : 'Failed to load glTF model';\n        console.error(message);\n        el.emit('model-error', {format: 'gltf', src: src});\n    });\n};\n"]}