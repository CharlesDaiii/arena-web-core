{"version":3,"sources":["components/arena-user.js"],"names":["enableChromeAEC","gainNode","audioEl","Audio","setAttribute","context","THREE","AudioContext","getContext","loopbackDestination","createMediaStreamDestination","outboundPeerConnection","RTCPeerConnection","inboundPeerConnection","onError","e","console","error","addEventListener","addIceCandidate","candidate","catch","srcObject","streams","stream","getTracks","forEach","track","addTrack","offer","createOffer","setLocalDescription","setRemoteDescription","answer","createAnswer","disconnect","ARENA","JitsiAPI","chromeSpatialAudioOn","connect","destination","AFRAME","registerComponent","schema","color","type","default","jitsiId","displayName","hasAudio","hasVideo","init","data","el","name","id","object3D","position","set","rotation","decodeName","personName","decodeURI","split","normalize","replace","headText","document","createElement","headModel","scale","appendChild","videoTrack","videoID","videoCubeDrawn","audioTrack","audioSource","tick","utils","throttleTick","drawMicrophone","micIconEl","querySelector","removeMicrophone","removeChild","drawVideoCube","videoCube","videoCubeDark","removeVideoCube","vidCube","getElementById","contains","vidCubeDark","aec","listener","audioCtx","resume","setTimeout","state","device","isMobile","test","navigator","userAgent","gain","body","removeEventListener","update","oldData","ready","getVideoTrack","videoElem","enabled","jistiAudioTrack","getAudioTrack","audioStream","MediaStream","sceneEl","audioListener","AudioListener","sceneObjects","myCamera","add","setMediaStreamSource","PositionalAudio","volume","setVolume","refDist","setRefDistance","rolloffFact","setRolloffFactor","distModel","setDistanceModel","camPos","entityPos","distance","distanceTo","cam","camera","frustum","Frustum","setFromProjectionMatrix","Matrix4","multiplyMatrices","projectionMatrix","matrixWorldInverse","inFieldOfView","containsPoint","maxAVDist","paused","pause","play"],"mappings":"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","file":"arena-user.08f03ff4.js","sourceRoot":"../src","sourcesContent":["/* global AFRAME, ARENA, THREE */\n\n/**\n * Workaround for AEC when using Web Audio API (https://bugs.chromium.org/p/chromium/issues/detail?id=687574)\n * https://github.com/mozilla/hubs/blob/master/src/systems/audio-system.js\n * @param {Object} gainNode\n */\nasync function enableChromeAEC(gainNode) {\n    /**\n     *  workaround for: https://bugs.chromium.org/p/chromium/issues/detail?id=687574\n     *  1. grab the GainNode from the scene's THREE.AudioListener\n     *  2. disconnect the GainNode from the AudioDestinationNode (basically the audio out),\n     *     this prevents hearing the audio twice.\n     *  3. create a local webrtc connection between two RTCPeerConnections (see this example: https://webrtc.github.io/samples/src/content/peerconnection/pc1/)\n     *  4. create a new MediaStreamDestination from the scene's THREE.AudioContext and connect the GainNode to it.\n     *  5. add the MediaStreamDestination's track  to one of those RTCPeerConnections\n     *  6. connect the other RTCPeerConnection's stream to a new audio element.\n     *  All audio is now routed through Chrome's audio mixer, thus enabling AEC,\n     *  while preserving all the audio processing that was performed via the WebAudio API.\n     */\n\n    const audioEl = new Audio();\n    audioEl.setAttribute('autoplay', 'autoplay');\n    audioEl.setAttribute('playsinline', 'playsinline');\n\n    const context = THREE.AudioContext.getContext();\n    const loopbackDestination = context.createMediaStreamDestination();\n    const outboundPeerConnection = new RTCPeerConnection();\n    const inboundPeerConnection = new RTCPeerConnection();\n\n    const onError = (e) => {\n        console.error('RTCPeerConnection loopback initialization error', e);\n    };\n\n    outboundPeerConnection.addEventListener('icecandidate', (e) => {\n        inboundPeerConnection.addIceCandidate(e.candidate).catch(onError);\n    });\n\n    inboundPeerConnection.addEventListener('icecandidate', (e) => {\n        outboundPeerConnection.addIceCandidate(e.candidate).catch(onError);\n    });\n\n    inboundPeerConnection.addEventListener('track', (e) => {\n        audioEl.srcObject = e.streams[0];\n    });\n\n    try {\n        /* The following should never fail, but just in case, we won't disconnect/reconnect\n           the gainNode unless all of this succeeds */\n        loopbackDestination.stream.getTracks().forEach((track) => {\n            outboundPeerConnection.addTrack(track, loopbackDestination.stream);\n        });\n\n        const offer = await outboundPeerConnection.createOffer();\n        outboundPeerConnection.setLocalDescription(offer);\n        await inboundPeerConnection.setRemoteDescription(offer);\n\n        const answer = await inboundPeerConnection.createAnswer();\n        inboundPeerConnection.setLocalDescription(answer);\n        outboundPeerConnection.setRemoteDescription(answer);\n\n        gainNode.disconnect();\n        if (ARENA.JitsiAPI.chromeSpatialAudioOn()) {\n            gainNode.connect(context.destination);\n        } else {\n            gainNode.connect(loopbackDestination);\n        }\n    } catch (e) {\n        onError(e);\n    }\n}\n\n/**\n * Another user's camera in the ARENA. Handles Jitsi and display name updates.\n *\n */\nAFRAME.registerComponent('arena-user', {\n    schema: {\n        color: {type: 'color', default: 'white'},\n        jitsiId: {type: 'string', default: ''},\n        displayName: {type: 'string', default: ''},\n        hasAudio: {type: 'boolean', default: false},\n        hasVideo: {type: 'boolean', default: false},\n    },\n\n    init: function() {\n        const data = this.data;\n        const el = this.el;\n        const name = el.id;\n\n        el.setAttribute('rotation.order', 'YXZ');\n        el.object3D.position.set(0, 0, 0);\n        el.object3D.rotation.set(0, 0, 0);\n\n        const decodeName = decodeURI(name.split('_')[2]);\n        const personName = decodeName.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n        this.headText = document.createElement('a-text');\n        this.headText.setAttribute('id', 'headtext_' + name);\n        this.headText.setAttribute('value', personName);\n        this.headText.setAttribute('position', '0 0.45 0.05');\n        this.headText.setAttribute('side', 'double');\n        this.headText.setAttribute('align', 'center');\n        this.headText.setAttribute('anchor', 'center');\n        this.headText.setAttribute('scale', '0.4 0.4 0.4');\n        this.headText.setAttribute('rotation', '0 180 0');\n        this.headText.setAttribute('color', data.color);\n        this.headText.setAttribute('width', 5); // try setting last\n\n        this.headModel = document.createElement('a-entity');\n        this.headModel.setAttribute('id', 'head-model_' + name);\n        this.headModel.setAttribute('rotation', '0 180 0');\n        this.headModel.object3D.scale.set(1, 1, 1);\n        this.headModel.setAttribute('dynamic-body', 'type', 'static');\n        this.headModel.setAttribute('gltf-model', 'url(models/Head.gltf)'); // actually a face mesh\n\n        el.appendChild(this.headText);\n        el.appendChild(this.headModel);\n\n        this.videoTrack = null;\n        this.videoID = null;\n        this.videoCubeDrawn = false;\n        this.audioTrack = null;\n        this.audioSource = null;\n\n        this.tick = AFRAME.utils.throttleTick(this.tick, 1000, this);\n    },\n\n    drawMicrophone() {\n        const el = this.el;\n\n        const name = 'muted_' + el.id;\n        let micIconEl = document.querySelector('#' + name);\n        if (!micIconEl) {\n            micIconEl = document.createElement('a-image');\n            micIconEl.setAttribute('id', name);\n            micIconEl.setAttribute('scale', '0.2 0.2 0.2');\n            micIconEl.setAttribute('position', '0 0.3 0.045');\n            micIconEl.setAttribute('src', 'url(src/icons/images/audio-off.png)');\n            el.appendChild(micIconEl);\n        }\n    },\n\n    removeMicrophone() {\n        const el = this.el;\n\n        const name = 'muted_' + el.id;\n        const micIconEl = document.querySelector('#' + name);\n        if (micIconEl) {\n            el.removeChild(micIconEl);\n        }\n    },\n\n    drawVideoCube() {\n        const el = this.el;\n\n        // attach video to head\n        const videoCube = document.createElement('a-box');\n        videoCube.setAttribute('id', this.videoID + 'cube');\n        videoCube.setAttribute('position', '0 0 0');\n        videoCube.setAttribute('scale', '0.6 0.4 0.6');\n        videoCube.setAttribute('material', 'shader', 'flat');\n        videoCube.setAttribute('src', `#${this.videoID}`); // video only (!audio)\n        videoCube.setAttribute('material-extras', 'encoding', 'sRGBEncoding');\n\n        const videoCubeDark = document.createElement('a-box');\n        videoCubeDark.setAttribute('id', this.videoID + 'cubeDark');\n        videoCubeDark.setAttribute('position', '0 0 0.01');\n        videoCubeDark.setAttribute('scale', '0.61 0.41 0.6');\n        videoCubeDark.setAttribute('material', 'shader', 'flat');\n        videoCubeDark.setAttribute('transparent', 'true');\n        videoCubeDark.setAttribute('color', 'black');\n        videoCubeDark.setAttribute('opacity', '0.8');\n\n        el.appendChild(videoCube);\n        el.appendChild(videoCubeDark);\n\n        this.videoCubeDrawn = true;\n    },\n\n    removeVideoCube() {\n        const el = this.el;\n\n        // remove video cubes\n        const vidCube = document.getElementById(this.videoID + 'cube');\n        if (el.contains(vidCube)) {\n            el.removeChild(vidCube);\n        }\n        const vidCubeDark = document.getElementById(this.videoID + 'cubeDark');\n        if (el.contains(vidCubeDark)) {\n            el.removeChild(vidCubeDark);\n        }\n        this.videoCubeDrawn = false;\n    },\n\n    aec(listener) {\n        // sorta fixes chrome echo bug\n        const audioCtx = THREE.AudioContext.getContext();\n        const resume = () => {\n            audioCtx.resume();\n            setTimeout(function() {\n                if (audioCtx.state === 'running') {\n                    if (!AFRAME.utils.device.isMobile() && /chrome/i.test(navigator.userAgent)) {\n                        enableChromeAEC(listener.gain);\n                    }\n                    document.body.removeEventListener('touchmove', resume, false);\n                    document.body.removeEventListener('mousemove', resume, false);\n                }\n            }, 0);\n        };\n        document.body.addEventListener('touchmove', resume, false);\n        document.body.addEventListener('mousemove', resume, false);\n    },\n\n    update: function(oldData) {\n        const data = this.data;\n        const el = this.el;\n\n        if (data.displayName !== oldData.displayName) {\n            const name = data.displayName.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n            this.headText.setAttribute('value', name);\n        }\n\n        if (ARENA.JitsiAPI.ready() && data.jitsiId) {\n            /* Handle Jitsi Video */\n            this.videoID = `video${data.jitsiId}`;\n            if (data.hasVideo) {\n                this.videoTrack = ARENA.JitsiAPI.getVideoTrack(data.jitsiId);\n                // draw video cube, but only if it didnt exist before\n                videoElem = document.getElementById(this.videoID);\n                if (videoElem && !this.videoCubeDrawn) {\n                    this.drawVideoCube();\n                }\n            } else {\n                // pause WebRTC video stream\n                if (this.videoTrack) {\n                    this.videoTrack.enabled = false;\n                }\n                this.removeVideoCube();\n            }\n\n            /* Handle Jitsi Audio */\n            if (data.hasAudio) {\n                this.removeMicrophone();\n\n                // set up positional audio, but only once per camera\n                const jistiAudioTrack = ARENA.JitsiAPI.getAudioTrack(data.jitsiId);\n                this.audioTrack = jistiAudioTrack.track;\n\n                // set up and attach positional audio\n                const audioStream = new MediaStream();\n                audioStream.addTrack(this.audioTrack);\n\n                const sceneEl = document.querySelector('a-scene');\n                let listener = null;\n                if (sceneEl.audioListener) {\n                    listener = sceneEl.audioListener;\n                } else {\n                    listener = new THREE.AudioListener();\n                    const camEl = ARENA.sceneObjects.myCamera.object3D;\n                    camEl.add(listener);\n                    sceneEl.audioListener = listener;\n                }\n\n                // create positional audio, but only if didn't exist before\n                if (!this.audioSource) {\n                    this.audioSource = new THREE.PositionalAudio(listener);\n                    this.audioSource.setMediaStreamSource(audioStream);\n                    el.object3D.add(this.audioSource);\n\n                    // set positional audio scene params\n                    if (ARENA.volume) {\n                        this.audioSource.setVolume(ARENA.volume);\n                    }\n                    if (ARENA.refDist) { // L-R panning\n                        this.audioSource.setRefDistance(ARENA.refDist);\n                    }\n                    if (ARENA.rolloffFact) {\n                        this.audioSource.setRolloffFactor(ARENA.rolloffFact);\n                    }\n                    if (ARENA.distModel) {\n                        this.audioSource.setDistanceModel(ARENA.distModel);\n                    }\n                } else {\n                    this.audioSource.setMediaStreamSource(audioStream);\n                }\n                this.aec(listener);\n            } else {\n                this.drawMicrophone();\n                // pause WebRTC audio stream\n                if (this.audioTrack) {\n                    this.audioTrack.enabled = false;\n                }\n            }\n        }\n    },\n\n    tick: function() {\n        const el = this.el;\n\n        const camPos = ARENA.sceneObjects.myCamera.object3D.position;\n        const entityPos = el.object3D.position;\n        const distance = camPos.distanceTo(entityPos);\n\n        if (this.videoTrack && this.videoID) {\n            // frustrum culling for WebRTC streams\n            const cam = ARENA.sceneObjects.myCamera.sceneEl.camera;\n            const frustum = new THREE.Frustum();\n            frustum.setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(cam.projectionMatrix,\n                cam.matrixWorldInverse));\n            const inFieldOfView = frustum.containsPoint(entityPos);\n\n            const videoElem = document.getElementById(this.videoID);\n            // check if A/V cut off distance has been reached\n            if (!inFieldOfView || distance > ARENA.maxAVDist) {\n                // pause WebRTC video stream\n                if (this.videoTrack) {\n                    this.videoTrack.enabled = false;\n                }\n                if (videoElem && !videoElem.paused) videoElem.pause();\n            } else {\n                // unpause WebRTC video stream\n                if (this.videoTrack) {\n                    this.videoTrack.enabled = true;\n                }\n                if (videoElem && videoElem.paused) videoElem.play();\n            }\n        }\n\n        if (this.audioTrack) {\n            // check if A/V cut off distance has been reached\n            if (distance > ARENA.maxAVDist) {\n                // pause WebRTC audio stream\n                if (this.audioTrack) {\n                    this.audioTrack.enabled = false;\n                }\n            } else {\n                // unpause WebRTC audio stream\n                if (this.audioTrack) {\n                    this.audioTrack.enabled = true;\n                }\n            }\n        }\n    },\n});\n"]}