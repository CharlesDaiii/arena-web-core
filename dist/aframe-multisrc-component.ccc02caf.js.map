{"version":3,"sources":["components/vendor/aframe-multisrc-component.js"],"names":["AFRAME","registerComponent","dependencies","schema","srcs","default","parse","value","length","split","srcspath","type","init","sides","el","getObject3D","geometry","groups","makeMaterials","styleMaterials","material","materials","materialListener","i","push","THREE","MeshStandardMaterial","name","update","parseSrcs","addTextures","textures","which","data","srcIndex","url","srcCheck","srcInline","inline","assetId","src","asset","document","getElementById","replace","includes","texture","map","needsUpdate","loader","TextureLoader","load","video","createElement","crossOrigin","loop","preload","play","videoTexture","VideoTexture","minFilter","LinearFilter","magFilter","format","RGBFormat","self","compChange","evt","detail","isAnimating","reduceMaterialChangedThrottle","addEventListener","animationCount","materialChangedByAnimation","components","animation","reset","forEach","event","styles","a","b","diff","utils","key","hasOwnProperty","granularChange","materialIndex","throttle","throttledEmitComponentChanged","emit","evtDetail","updateSchema","newSchema","extendSchema","remove","defaultMaterial","removeEventListener"],"mappings":"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","file":"aframe-multisrc-component.ccc02caf.js","sourceRoot":"../src","sourcesContent":["//aframe multisrc component\n\nAFRAME.registerComponent('multisrc', {\n  \n  dependencies: ['material'],\n      \n  schema: {\n      srcs: {\n          default: [],\n          parse: function (value) {\n              if ( value.length == 0 ){\n                return ''\n              }\n              else{\n                return value.split(',');\n              }\n          }\n      },\n      srcspath: {type: 'string', default: ''},\n  },//end schema\n\n  init: function () {\n      \n      //get the number of 'sides' (groups) of the shape this is attached to\n      this.sides = this.el.getObject3D('mesh').geometry.groups.length\n\n      //make new materials and add them to array\n      this.makeMaterials();\n      \n      //style the new materials by inheriting from default material component\n      this.styleMaterials();\n\n      //update the mesh with new materials array\n      this.el.getObject3D('mesh').material = this.materials\n    \n      //set up listeners for changes in default material\n      this.materialListener();\n      \n  },//end init\n  \n  makeMaterials: function() {\n      \n      //make an empty array to load some new materials into\n      this.materials = []\n  \n      //get the number of sides of the geometry make a separate material for each\n      for(i=0;i<this.sides;i++){\n\n        //add plain new material to array, give it a unique name\n        this.materials.push( new THREE.MeshStandardMaterial({ name: 'material-' + i + ''}) )\n\n      }//end for images loop\n  \n  },//end makeMaterials\n  \n  update: function (){\n    \n      this.parseSrcs();\n\n      this.addTextures();\n      \n  },//end update\n  \n  parseSrcs: function(){\n  \n      //tidy up input from srcs\n      // - video or image?, inline URL or id to asset?, all 'srcs' or 'src1' 'src2'? etc\n      //make an array of objects with clean data\n      \n      //make an empty array to store objects\n      this.textures = []\n            \n      //populate with objects for each\n      for (i=0;i<this.sides;i++){   \n        //choose attribute to use, 'srcs' or 'src1','src2' etc. can't use both \n        var which;\n        if ( this.data.srcs == '' ){\n          which = this.data['src'+i]\n        }\n        else{\n          which = this.data.srcs[i]\n        }\n        //add empty objects\n        this.textures.push({})\n        //add a src+index identifier for each\n        this.textures[i].srcIndex = \"src\"+i\n        //add a url for each\n        this.textures[i].url = srcCheck(this.data, which, i).url\n        //add a type for each\n        this.textures[i].type = srcCheck(this.data, which, i).type\n        //add an inline ref for each, need this for videos\n        this.textures[i].srcInline = srcCheck(this.data, which, i).inline\n        //if there's an id ref to assets tag, store, again for videos\n        this.textures[i].assetId = srcCheck(this.data, which, i).assetId\n      }\n\n      function srcCheck(data, which, i){  \n        \n        //inline or reference, image or video, 'srcs' attribute or 'src1' 'src2' etc.\n\n        var src = which\n        \n        //if one doesn't exist, don't break, just have empty values\n        if (typeof src === 'undefined' || src == ''){\n          url = ''\n          type = ''\n          inline = ''\n          assetId = ''\n        }\n        \n        else{\n          \n          var asset;\n          var url;\n          var type;\n          var inline;\n          var assetId;\n\n          //if its not a preloaded asset, its an inline url so get that\n          if ( document.getElementById( src.replace('#','') ) === null ){ \n            asset = src\n            inline = true\n          }\n          //otherwise its a preloaded asset so get the src from tag\n          else{\n            assetId = src\n            asset = document.getElementById( src.replace('#','') ).src\n            inline = false\n          }\n          //combine asset string with srcpath to make url\n          url = data.srcspath+asset\n\n          //check type, image or video\n          //check if its an image or video\n          if ( url.includes('.jpg') || url.includes('.jpeg') || url.includes('.png') || url.includes('.gif') ){ \n            type = 'image'\n          }\n          else{\n            type = 'video'\n          }\n        }//end else of is src defined\n\n        return {\n          url: url,\n          type: type,\n          inline: inline,\n          assetId: assetId,\n        }//end return\n        \n      }//end srcCheck\n    \n  },//end parseSrcs\n  \n  addTextures: function(){\n      \n      //loop through all textures and apply as defined\n      for(i=0;i<this.textures.length;i++){\n        \n          //each texture\n          var texture = this.textures[i]\n          \n          //get each material to update map\n          var material = this.materials[i]\n\n          //if the texture has no image/video assigned, undo any changes that have been made\n          if ( texture.url == '' ){\n            \n            material.map = null\n            material.needsUpdate = true;\n            \n          }\n\n          //else update the material map with image/video\n          else{\n\n            //if its an image\n            if ( texture.type == 'image' ){\n\n              //make a 3js loader for image textures\n              var loader = new THREE.TextureLoader();\n\n              //give each material the image asset\n              material.map = loader.load(texture.url)\n              material.needsUpdate = true;\n\n            }//end if its an image\n\n            //else its a video, need to do a bit more\n            else{\n              \n              var video;\n              //if its an inline src\n              if ( texture.srcInline ){ \n                video = document.createElement('video')\n                video.src = texture.url\n                video.crossOrigin = 'anonymous';\n                video.loop = true;\n                video.preload = 'auto';\n                video.load();\n                video.play(); \n              }\n              //otherwise its an asset \n              else{\n                video = document.getElementById( texture.assetId.replace('#','') )\n                video.src = texture.url\n                video.load();\n              }//end else its an asset\n              \n              //in any case..\n              var videoTexture = new THREE.VideoTexture(video);\n              videoTexture.needsUpdate;\n              videoTexture.minFilter = THREE.LinearFilter;\n              videoTexture.magFilter = THREE.LinearFilter;\n              videoTexture.format = THREE.RGBFormat;\n              material.map = videoTexture\n              material.needsUpdate = true;\n\n            }//end it its a video\n            \n          }//end else texture has video/image assigned\n        \n      }//end for textures\n    \n  },//end addTextures\n  \n  materialListener: function() {\n      \n      //to listen for changes in components attached to parent entity\n      //Note: default components, position, scale, rotation, visible, do not fire componentchanged unless they are specified as attributes on the entity\n      //not an issue here as we are only looking for changes to material which always seems to fire, maybe because we have a dependency?\n      \n      var self = this //can't get this inside eventListener\n      \n      //if componentchange is for material, run styleMaterials\n      this.compChange = function (evt) {\n        \n          //if the material is being changed by an animation, reduce throttle to keep up with changes and styleMaterials\n          if ( evt.detail.name == 'material' && this.isAnimating ){\n            self.reduceMaterialChangedThrottle(0);\n            self.styleMaterials();\n          }\n          //else if the material is being changed without animation\n          else if( evt.detail.name == 'material' ){\n            self.styleMaterials();\n          }\n          else{\n            //may not always fire, see above\n          }\n         \n      }//end compChange\n      \n      //check for component changes and then run the above compchange function\n      this.el.addEventListener('componentchanged', this.compChange);\n    \n      //handling changes to animation, need to dethrotle componentchange event to keep up, but put back when animation is over\n    \n      //store a default state\n      this.isAnimating = false\n      //keep a count of how many are going on at once, to handle events on multiple animations\n      this.animationCount = 0\n    \n      //add another listener here for animationbegin\n      this.materialChangedByAnimation = function (evt) {\n        \n        //if an animation has begun set isAnimating to true so that dethrottle can then be activated in componentchanged, also add an animation to animationCount\n        if ( evt.type == 'animationbegin' || evt.type == 'animationstart' ){\n          this.isAnimating = true\n          self.animationCount++\n        }\n        //else if its ended (animationcomplete) set it to false and put throttle back to its original state for performance\n        else if ( evt.type == 'animationcomplete' || evt.type == 'animationend' ){\n          this.isAnimating = false\n          self.animationCount--\n          //once there are no animations running, throtle again\n          if ( self.animationCount == 0  ){\n            self.reduceMaterialChangedThrottle(200);\n          }\n          //for animation component only\n          //workaround animationcomplete bug suggested here\n          //https://github.com/ngokevin/kframe/issues/137#issuecomment-398907856\n          //reset the animation - seems to work!\n          if ( evt.type == 'animationcomplete' ){\n            self.el.components[evt.detail.name].animation.reset();\n          }\n          \n        }\n        \n      }\n      \n      //make an array of animation events \n      //a mix of animation component events and <a-animation> events to handle both\n      var animationEventsArray = ['animationbegin', 'animationstart', 'animationcomplete', 'animationend']\n      \n      //attach them all to listen for each\n      animationEventsArray.forEach(function(event) {\n        self.el.addEventListener(event, self.materialChangedByAnimation)\n      });\n    \n  },//end materialListener\n  \n  styleMaterials: function(){\n    \n      //to inherit changes from material component\n    \n      //get attached material component styles to copy\n      var styles = this.el.components.material.material  \n      \n      //get number of sides and loop through them\n      for(i=0;i<this.sides;i++){\n    \n        //get each material\n        var material = this.materials[i]\n        \n          //get the difference between default material and our material\n          var a = material\n          var b = styles\n          var diff = AFRAME.utils.diff (a, b)\n\n            //use the different styles to style the materials unless it is the uuid, map or name \n            for (var key in diff) {\n                if (material.hasOwnProperty(key)) {\n\n                    //if its the uuid, map or name don't copy\n                    if ( key == 'uuid' || key == 'map' || key == 'name' ){\n                    }\n                    //else copy it over\n                    else{\n                      material[key] = styles[key]\n                    }\n\n                }//end if has own property\n            }//end for keys in data\n        \n      }//end for images loop\n  \n  },//end styleMaterials\n  \n  granularChange: function (materialIndex) {\n      \n      //get and return a specific material/side for styling individually - advanced\n      var material = this.el.getObject3D('mesh').material[materialIndex]\n      return material\n    \n  },//end granularChange\n  \n  reduceMaterialChangedThrottle: function(throttle){\n  \n      //change throttle on material componentchanged so as to update quickly enough for animations, from 200 to 0\n      var material = this.el.components.material\n      \n      material.throttledEmitComponentChanged = AFRAME.utils.throttle(function emitChange () { \n        material.el.emit('componentchanged', material.evtDetail, false); \n      }, throttle);\n\n  },//end reduceMaterialChangedThrottle:\n  \n  updateSchema: function () {\n        \n        //update schema with an attribute for each individual side of attached geometry\n    \n        //have to get the sides afresh as this is run before init\n        var sides = this.el.getObject3D('mesh').geometry.groups.length  \n        var newSchema = {}\n        for (i = 0; i < sides; i++){\n            newSchema[\"src\"+i] = {type: 'string', default: ''};\n        }\n        this.extendSchema(newSchema);\n  },//end updateSchema\n  \n  remove: function(){\n    \n    //removes this multimaterial from mesh, adds the default material back on, removes event listeners and puts material componentchanged throttle back to normal if necessary\n    \n    //get the default material\n    var defaultMaterial = this.el.components.material.material \n    \n    //update the mesh with default material\n    this.el.getObject3D('mesh').material = defaultMaterial\n    \n    //remove componentchanged eventlistener\n    this.el.removeEventListener('componentchanged', this.compChange);\n    \n    //removes all animation event listeners at once\n    var animationEventsArray = ['animationbegin', 'animationstart', 'animationcomplete', 'animationend']\n    animationEventsArray.forEach(function(event) {\n      this.el.addEventListener(event, this.materialChangedByAnimation)\n    });\n    \n    //put component changed throttle back to normal (in case it was removed while animating)\n    this.reduceMaterialChangedThrottle(200);\n    \n  },//end remove\n\n});//end multisrc"]}