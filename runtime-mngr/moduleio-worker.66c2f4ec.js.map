{"version":3,"sources":["node_modules/paho-mqtt/paho-mqtt.js","mqtt-client.js","worker-msgs.js","sa-cbuffer.js","moduleio-worker.js"],"names":["_this","MqttClient","constructor","st","settings","uri","undefined","host","port","path","clientid","Math","round","random","subscribeTopics","onConnectCallback","onConnectCallbackContext","onMessageCallback","willMessage","Paho","Message","dbg","reconnect","useSSL","destinationName","willMessageTopic","console","log","connect","mqttc","Client","wss","Number","onConnectionLost","bind","onMessageArrived","Promise","resolve","reject","onSuccess","length","subscribe","onFailure","Error","directMesssage","topic","payload","JSON","stringify","msg","disconnect","err","reConnect","clientConnect","responseObject","errorCode","errorMessage","message","payloadString","publish","send","unsubscribe","exports","msgType","start","stop","pub_msg","sub_msg","new_stream","signal","finish","DFT_BUFFER_SIZE","SharedArrayCircularBuffer","createSharedBuffer","byteSize","buffer","SharedArrayBuffer","Uint32Array","BYTES_PER_ELEMENT","uint32","spinlock","Uint8Array","desc","byteLength","bytes","logOverwrite","pop","nbytes","Atomics","data","compareExchange","min","i","push","ii","size","setOverwriteLog","value","stdin_topic_prefix","cb","mc","mod","onMqttMessage","modUuid","TextEncoder","encode","onmessage","e","type","WorkerMessages","modData","arts_mod_instance_data","uuid","reg_topic","ARTSMessages","Action","delete","stdin_topic","shared_array_buffer","worker_port","mod_uuid","signo","channel","params","dst"],"mappings":"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","file":"moduleio-worker.66c2f4ec.js","sourceRoot":"..","sourcesContent":["/*******************************************************************************\n * Copyright (c) 2013 IBM Corp.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    http://www.eclipse.org/legal/epl-v10.html\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Andrew Banks - initial API and implementation and initial documentation\n *******************************************************************************/\n\n\n// Only expose a single object name in the global namespace.\n// Everything must go through this module. Global Paho module\n// only has a single public function, client, which returns\n// a Paho client object given connection details.\n\n/**\n * Send and receive messages using web browsers.\n * <p>\n * This programming interface lets a JavaScript client application use the MQTT V3.1 or\n * V3.1.1 protocol to connect to an MQTT-supporting messaging server.\n *\n * The function supported includes:\n * <ol>\n * <li>Connecting to and disconnecting from a server. The server is identified by its host name and port number.\n * <li>Specifying options that relate to the communications link with the server,\n * for example the frequency of keep-alive heartbeats, and whether SSL/TLS is required.\n * <li>Subscribing to and receiving messages from MQTT Topics.\n * <li>Publishing messages to MQTT Topics.\n * </ol>\n * <p>\n * The API consists of two main objects:\n * <dl>\n * <dt><b>{@link Paho.Client}</b></dt>\n * <dd>This contains methods that provide the functionality of the API,\n * including provision of callbacks that notify the application when a message\n * arrives from or is delivered to the messaging server,\n * or when the status of its connection to the messaging server changes.</dd>\n * <dt><b>{@link Paho.Message}</b></dt>\n * <dd>This encapsulates the payload of the message along with various attributes\n * associated with its delivery, in particular the destination to which it has\n * been (or is about to be) sent.</dd>\n * </dl>\n * <p>\n * The programming interface validates parameters passed to it, and will throw\n * an Error containing an error message intended for developer use, if it detects\n * an error with any parameter.\n * <p>\n * Example:\n *\n * <code><pre>\nvar client = new Paho.MQTT.Client(location.hostname, Number(location.port), \"clientId\");\nclient.onConnectionLost = onConnectionLost;\nclient.onMessageArrived = onMessageArrived;\nclient.connect({onSuccess:onConnect});\n\nfunction onConnect() {\n  // Once a connection has been made, make a subscription and send a message.\n  console.log(\"onConnect\");\n  client.subscribe(\"/World\");\n  var message = new Paho.MQTT.Message(\"Hello\");\n  message.destinationName = \"/World\";\n  client.send(message);\n};\nfunction onConnectionLost(responseObject) {\n  if (responseObject.errorCode !== 0)\n\tconsole.log(\"onConnectionLost:\"+responseObject.errorMessage);\n};\nfunction onMessageArrived(message) {\n  console.log(\"onMessageArrived:\"+message.payloadString);\n  client.disconnect();\n};\n * </pre></code>\n * @namespace Paho\n */\n\n/* jshint shadow:true */\n(function ExportLibrary(root, factory) {\n\tif(typeof exports === \"object\" && typeof module === \"object\"){\n\t\tmodule.exports = factory();\n\t} else if (typeof define === \"function\" && define.amd){\n\t\tdefine(factory);\n\t} else if (typeof exports === \"object\"){\n\t\texports = factory();\n\t} else {\n\t\t//if (typeof root.Paho === \"undefined\"){\n\t\t//\troot.Paho = {};\n\t\t//}\n\t\troot.Paho = factory();\n\t}\n})(this, function LibraryFactory(){\n\n\n\tvar PahoMQTT = (function (global) {\n\n\t// Private variables below, these are only visible inside the function closure\n\t// which is used to define the module.\n\tvar version = \"@VERSION@-@BUILDLEVEL@\";\n\n\t/**\n\t * @private\n\t */\n\tvar localStorage = global.localStorage || (function () {\n\t\tvar data = {};\n\n\t\treturn {\n\t\t\tsetItem: function (key, item) { data[key] = item; },\n\t\t\tgetItem: function (key) { return data[key]; },\n\t\t\tremoveItem: function (key) { delete data[key]; },\n\t\t};\n\t})();\n\n\t\t/**\n\t * Unique message type identifiers, with associated\n\t * associated integer values.\n\t * @private\n\t */\n\t\tvar MESSAGE_TYPE = {\n\t\t\tCONNECT: 1,\n\t\t\tCONNACK: 2,\n\t\t\tPUBLISH: 3,\n\t\t\tPUBACK: 4,\n\t\t\tPUBREC: 5,\n\t\t\tPUBREL: 6,\n\t\t\tPUBCOMP: 7,\n\t\t\tSUBSCRIBE: 8,\n\t\t\tSUBACK: 9,\n\t\t\tUNSUBSCRIBE: 10,\n\t\t\tUNSUBACK: 11,\n\t\t\tPINGREQ: 12,\n\t\t\tPINGRESP: 13,\n\t\t\tDISCONNECT: 14\n\t\t};\n\n\t\t// Collection of utility methods used to simplify module code\n\t\t// and promote the DRY pattern.\n\n\t\t/**\n\t * Validate an object's parameter names to ensure they\n\t * match a list of expected variables name for this option\n\t * type. Used to ensure option object passed into the API don't\n\t * contain erroneous parameters.\n\t * @param {Object} obj - User options object\n\t * @param {Object} keys - valid keys and types that may exist in obj.\n\t * @throws {Error} Invalid option parameter found.\n\t * @private\n\t */\n\t\tvar validate = function(obj, keys) {\n\t\t\tfor (var key in obj) {\n\t\t\t\tif (obj.hasOwnProperty(key)) {\n\t\t\t\t\tif (keys.hasOwnProperty(key)) {\n\t\t\t\t\t\tif (typeof obj[key] !== keys[key])\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof obj[key], key]));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar errorStr = \"Unknown property, \" + key + \". Valid properties are:\";\n\t\t\t\t\t\tfor (var validKey in keys)\n\t\t\t\t\t\t\tif (keys.hasOwnProperty(validKey))\n\t\t\t\t\t\t\t\terrorStr = errorStr+\" \"+validKey;\n\t\t\t\t\t\tthrow new Error(errorStr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t * Return a new function which runs the user function bound\n\t * to a fixed scope.\n\t * @param {function} User function\n\t * @param {object} Function scope\n\t * @return {function} User function bound to another scope\n\t * @private\n\t */\n\t\tvar scope = function (f, scope) {\n\t\t\treturn function () {\n\t\t\t\treturn f.apply(scope, arguments);\n\t\t\t};\n\t\t};\n\n\t\t/**\n\t * Unique message type identifiers, with associated\n\t * associated integer values.\n\t * @private\n\t */\n\t\tvar ERROR = {\n\t\t\tOK: {code:0, text:\"AMQJSC0000I OK.\"},\n\t\t\tCONNECT_TIMEOUT: {code:1, text:\"AMQJSC0001E Connect timed out.\"},\n\t\t\tSUBSCRIBE_TIMEOUT: {code:2, text:\"AMQJS0002E Subscribe timed out.\"},\n\t\t\tUNSUBSCRIBE_TIMEOUT: {code:3, text:\"AMQJS0003E Unsubscribe timed out.\"},\n\t\t\tPING_TIMEOUT: {code:4, text:\"AMQJS0004E Ping timed out.\"},\n\t\t\tINTERNAL_ERROR: {code:5, text:\"AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}\"},\n\t\t\tCONNACK_RETURNCODE: {code:6, text:\"AMQJS0006E Bad Connack return code:{0} {1}.\"},\n\t\t\tSOCKET_ERROR: {code:7, text:\"AMQJS0007E Socket error:{0}.\"},\n\t\t\tSOCKET_CLOSE: {code:8, text:\"AMQJS0008I Socket closed.\"},\n\t\t\tMALFORMED_UTF: {code:9, text:\"AMQJS0009E Malformed UTF data:{0} {1} {2}.\"},\n\t\t\tUNSUPPORTED: {code:10, text:\"AMQJS0010E {0} is not supported by this browser.\"},\n\t\t\tINVALID_STATE: {code:11, text:\"AMQJS0011E Invalid state {0}.\"},\n\t\t\tINVALID_TYPE: {code:12, text:\"AMQJS0012E Invalid type {0} for {1}.\"},\n\t\t\tINVALID_ARGUMENT: {code:13, text:\"AMQJS0013E Invalid argument {0} for {1}.\"},\n\t\t\tUNSUPPORTED_OPERATION: {code:14, text:\"AMQJS0014E Unsupported operation.\"},\n\t\t\tINVALID_STORED_DATA: {code:15, text:\"AMQJS0015E Invalid data in local storage key={0} value={1}.\"},\n\t\t\tINVALID_MQTT_MESSAGE_TYPE: {code:16, text:\"AMQJS0016E Invalid MQTT message type {0}.\"},\n\t\t\tMALFORMED_UNICODE: {code:17, text:\"AMQJS0017E Malformed Unicode string:{0} {1}.\"},\n\t\t\tBUFFER_FULL: {code:18, text:\"AMQJS0018E Message buffer is full, maximum buffer size: {0}.\"},\n\t\t};\n\n\t\t/** CONNACK RC Meaning. */\n\t\tvar CONNACK_RC = {\n\t\t\t0:\"Connection Accepted\",\n\t\t\t1:\"Connection Refused: unacceptable protocol version\",\n\t\t\t2:\"Connection Refused: identifier rejected\",\n\t\t\t3:\"Connection Refused: server unavailable\",\n\t\t\t4:\"Connection Refused: bad user name or password\",\n\t\t\t5:\"Connection Refused: not authorized\"\n\t\t};\n\n\t/**\n\t * Format an error message text.\n\t * @private\n\t * @param {error} ERROR value above.\n\t * @param {substitutions} [array] substituted into the text.\n\t * @return the text with the substitutions made.\n\t */\n\t\tvar format = function(error, substitutions) {\n\t\t\tvar text = error.text;\n\t\t\tif (substitutions) {\n\t\t\t\tvar field,start;\n\t\t\t\tfor (var i=0; i<substitutions.length; i++) {\n\t\t\t\t\tfield = \"{\"+i+\"}\";\n\t\t\t\t\tstart = text.indexOf(field);\n\t\t\t\t\tif(start > 0) {\n\t\t\t\t\t\tvar part1 = text.substring(0,start);\n\t\t\t\t\t\tvar part2 = text.substring(start+field.length);\n\t\t\t\t\t\ttext = part1+substitutions[i]+part2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn text;\n\t\t};\n\n\t\t//MQTT protocol and version          6    M    Q    I    s    d    p    3\n\t\tvar MqttProtoIdentifierv3 = [0x00,0x06,0x4d,0x51,0x49,0x73,0x64,0x70,0x03];\n\t\t//MQTT proto/version for 311         4    M    Q    T    T    4\n\t\tvar MqttProtoIdentifierv4 = [0x00,0x04,0x4d,0x51,0x54,0x54,0x04];\n\n\t\t/**\n\t * Construct an MQTT wire protocol message.\n\t * @param type MQTT packet type.\n\t * @param options optional wire message attributes.\n\t *\n\t * Optional properties\n\t *\n\t * messageIdentifier: message ID in the range [0..65535]\n\t * payloadMessage:\tApplication Message - PUBLISH only\n\t * connectStrings:\tarray of 0 or more Strings to be put into the CONNECT payload\n\t * topics:\t\t\tarray of strings (SUBSCRIBE, UNSUBSCRIBE)\n\t * requestQoS:\t\tarray of QoS values [0..2]\n\t *\n\t * \"Flag\" properties\n\t * cleanSession:\ttrue if present / false if absent (CONNECT)\n\t * willMessage:  \ttrue if present / false if absent (CONNECT)\n\t * isRetained:\t\ttrue if present / false if absent (CONNECT)\n\t * userName:\t\ttrue if present / false if absent (CONNECT)\n\t * password:\t\ttrue if present / false if absent (CONNECT)\n\t * keepAliveInterval:\tinteger [0..65535]  (CONNECT)\n\t *\n\t * @private\n\t * @ignore\n\t */\n\t\tvar WireMessage = function (type, options) {\n\t\t\tthis.type = type;\n\t\t\tfor (var name in options) {\n\t\t\t\tif (options.hasOwnProperty(name)) {\n\t\t\t\t\tthis[name] = options[name];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tWireMessage.prototype.encode = function() {\n\t\t// Compute the first byte of the fixed header\n\t\t\tvar first = ((this.type & 0x0f) << 4);\n\n\t\t\t/*\n\t\t * Now calculate the length of the variable header + payload by adding up the lengths\n\t\t * of all the component parts\n\t\t */\n\n\t\t\tvar remLength = 0;\n\t\t\tvar topicStrLength = [];\n\t\t\tvar destinationNameLength = 0;\n\t\t\tvar willMessagePayloadBytes;\n\n\t\t\t// if the message contains a messageIdentifier then we need two bytes for that\n\t\t\tif (this.messageIdentifier !== undefined)\n\t\t\t\tremLength += 2;\n\n\t\t\tswitch(this.type) {\n\t\t\t// If this a Connect then we need to include 12 bytes for its header\n\t\t\tcase MESSAGE_TYPE.CONNECT:\n\t\t\t\tswitch(this.mqttVersion) {\n\t\t\t\tcase 3:\n\t\t\t\t\tremLength += MqttProtoIdentifierv3.length + 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tremLength += MqttProtoIdentifierv4.length + 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tremLength += UTF8Length(this.clientId) + 2;\n\t\t\t\tif (this.willMessage !== undefined) {\n\t\t\t\t\tremLength += UTF8Length(this.willMessage.destinationName) + 2;\n\t\t\t\t\t// Will message is always a string, sent as UTF-8 characters with a preceding length.\n\t\t\t\t\twillMessagePayloadBytes = this.willMessage.payloadBytes;\n\t\t\t\t\tif (!(willMessagePayloadBytes instanceof Uint8Array))\n\t\t\t\t\t\twillMessagePayloadBytes = new Uint8Array(payloadBytes);\n\t\t\t\t\tremLength += willMessagePayloadBytes.byteLength +2;\n\t\t\t\t}\n\t\t\t\tif (this.userName !== undefined)\n\t\t\t\t\tremLength += UTF8Length(this.userName) + 2;\n\t\t\t\tif (this.password !== undefined)\n\t\t\t\t\tremLength += UTF8Length(this.password) + 2;\n\t\t\t\tbreak;\n\n\t\t\t// Subscribe, Unsubscribe can both contain topic strings\n\t\t\tcase MESSAGE_TYPE.SUBSCRIBE:\n\t\t\t\tfirst |= 0x02; // Qos = 1;\n\t\t\t\tfor ( var i = 0; i < this.topics.length; i++) {\n\t\t\t\t\ttopicStrLength[i] = UTF8Length(this.topics[i]);\n\t\t\t\t\tremLength += topicStrLength[i] + 2;\n\t\t\t\t}\n\t\t\t\tremLength += this.requestedQos.length; // 1 byte for each topic's Qos\n\t\t\t\t// QoS on Subscribe only\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.UNSUBSCRIBE:\n\t\t\t\tfirst |= 0x02; // Qos = 1;\n\t\t\t\tfor ( var i = 0; i < this.topics.length; i++) {\n\t\t\t\t\ttopicStrLength[i] = UTF8Length(this.topics[i]);\n\t\t\t\t\tremLength += topicStrLength[i] + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBREL:\n\t\t\t\tfirst |= 0x02; // Qos = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\n\t\t\t\tif (this.payloadMessage.duplicate) first |= 0x08;\n\t\t\t\tfirst  = first |= (this.payloadMessage.qos << 1);\n\t\t\t\tif (this.payloadMessage.retained) first |= 0x01;\n\t\t\t\tdestinationNameLength = UTF8Length(this.payloadMessage.destinationName);\n\t\t\t\tremLength += destinationNameLength + 2;\n\t\t\t\tvar payloadBytes = this.payloadMessage.payloadBytes;\n\t\t\t\tremLength += payloadBytes.byteLength;\n\t\t\t\tif (payloadBytes instanceof ArrayBuffer)\n\t\t\t\t\tpayloadBytes = new Uint8Array(payloadBytes);\n\t\t\t\telse if (!(payloadBytes instanceof Uint8Array))\n\t\t\t\t\tpayloadBytes = new Uint8Array(payloadBytes.buffer);\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.DISCONNECT:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Now we can allocate a buffer for the message\n\n\t\t\tvar mbi = encodeMBI(remLength);  // Convert the length to MQTT MBI format\n\t\t\tvar pos = mbi.length + 1;        // Offset of start of variable header\n\t\t\tvar buffer = new ArrayBuffer(remLength + pos);\n\t\t\tvar byteStream = new Uint8Array(buffer);    // view it as a sequence of bytes\n\n\t\t\t//Write the fixed header into the buffer\n\t\t\tbyteStream[0] = first;\n\t\t\tbyteStream.set(mbi,1);\n\n\t\t\t// If this is a PUBLISH then the variable header starts with a topic\n\t\t\tif (this.type == MESSAGE_TYPE.PUBLISH)\n\t\t\t\tpos = writeString(this.payloadMessage.destinationName, destinationNameLength, byteStream, pos);\n\t\t\t// If this is a CONNECT then the variable header contains the protocol name/version, flags and keepalive time\n\n\t\t\telse if (this.type == MESSAGE_TYPE.CONNECT) {\n\t\t\t\tswitch (this.mqttVersion) {\n\t\t\t\tcase 3:\n\t\t\t\t\tbyteStream.set(MqttProtoIdentifierv3, pos);\n\t\t\t\t\tpos += MqttProtoIdentifierv3.length;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tbyteStream.set(MqttProtoIdentifierv4, pos);\n\t\t\t\t\tpos += MqttProtoIdentifierv4.length;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvar connectFlags = 0;\n\t\t\t\tif (this.cleanSession)\n\t\t\t\t\tconnectFlags = 0x02;\n\t\t\t\tif (this.willMessage !== undefined ) {\n\t\t\t\t\tconnectFlags |= 0x04;\n\t\t\t\t\tconnectFlags |= (this.willMessage.qos<<3);\n\t\t\t\t\tif (this.willMessage.retained) {\n\t\t\t\t\t\tconnectFlags |= 0x20;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.userName !== undefined)\n\t\t\t\t\tconnectFlags |= 0x80;\n\t\t\t\tif (this.password !== undefined)\n\t\t\t\t\tconnectFlags |= 0x40;\n\t\t\t\tbyteStream[pos++] = connectFlags;\n\t\t\t\tpos = writeUint16 (this.keepAliveInterval, byteStream, pos);\n\t\t\t}\n\n\t\t\t// Output the messageIdentifier - if there is one\n\t\t\tif (this.messageIdentifier !== undefined)\n\t\t\t\tpos = writeUint16 (this.messageIdentifier, byteStream, pos);\n\n\t\t\tswitch(this.type) {\n\t\t\tcase MESSAGE_TYPE.CONNECT:\n\t\t\t\tpos = writeString(this.clientId, UTF8Length(this.clientId), byteStream, pos);\n\t\t\t\tif (this.willMessage !== undefined) {\n\t\t\t\t\tpos = writeString(this.willMessage.destinationName, UTF8Length(this.willMessage.destinationName), byteStream, pos);\n\t\t\t\t\tpos = writeUint16(willMessagePayloadBytes.byteLength, byteStream, pos);\n\t\t\t\t\tbyteStream.set(willMessagePayloadBytes, pos);\n\t\t\t\t\tpos += willMessagePayloadBytes.byteLength;\n\n\t\t\t\t}\n\t\t\t\tif (this.userName !== undefined)\n\t\t\t\t\tpos = writeString(this.userName, UTF8Length(this.userName), byteStream, pos);\n\t\t\t\tif (this.password !== undefined)\n\t\t\t\t\tpos = writeString(this.password, UTF8Length(this.password), byteStream, pos);\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\n\t\t\t\t// PUBLISH has a text or binary payload, if text do not add a 2 byte length field, just the UTF characters.\n\t\t\t\tbyteStream.set(payloadBytes, pos);\n\n\t\t\t\tbreak;\n\n\t\t\t\t//    \t    case MESSAGE_TYPE.PUBREC:\n\t\t\t\t//    \t    case MESSAGE_TYPE.PUBREL:\n\t\t\t\t//    \t    case MESSAGE_TYPE.PUBCOMP:\n\t\t\t\t//    \t    \tbreak;\n\n\t\t\tcase MESSAGE_TYPE.SUBSCRIBE:\n\t\t\t\t// SUBSCRIBE has a list of topic strings and request QoS\n\t\t\t\tfor (var i=0; i<this.topics.length; i++) {\n\t\t\t\t\tpos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\n\t\t\t\t\tbyteStream[pos++] = this.requestedQos[i];\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.UNSUBSCRIBE:\n\t\t\t\t// UNSUBSCRIBE has a list of topic strings\n\t\t\t\tfor (var i=0; i<this.topics.length; i++)\n\t\t\t\t\tpos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// Do nothing.\n\t\t\t}\n\n\t\t\treturn buffer;\n\t\t};\n\n\t\tfunction decodeMessage(input,pos) {\n\t\t\tvar startingPos = pos;\n\t\t\tvar first = input[pos];\n\t\t\tvar type = first >> 4;\n\t\t\tvar messageInfo = first &= 0x0f;\n\t\t\tpos += 1;\n\n\n\t\t\t// Decode the remaining length (MBI format)\n\n\t\t\tvar digit;\n\t\t\tvar remLength = 0;\n\t\t\tvar multiplier = 1;\n\t\t\tdo {\n\t\t\t\tif (pos == input.length) {\n\t\t\t\t\treturn [null,startingPos];\n\t\t\t\t}\n\t\t\t\tdigit = input[pos++];\n\t\t\t\tremLength += ((digit & 0x7F) * multiplier);\n\t\t\t\tmultiplier *= 128;\n\t\t\t} while ((digit & 0x80) !== 0);\n\n\t\t\tvar endPos = pos+remLength;\n\t\t\tif (endPos > input.length) {\n\t\t\t\treturn [null,startingPos];\n\t\t\t}\n\n\t\t\tvar wireMessage = new WireMessage(type);\n\t\t\tswitch(type) {\n\t\t\tcase MESSAGE_TYPE.CONNACK:\n\t\t\t\tvar connectAcknowledgeFlags = input[pos++];\n\t\t\t\tif (connectAcknowledgeFlags & 0x01)\n\t\t\t\t\twireMessage.sessionPresent = true;\n\t\t\t\twireMessage.returnCode = input[pos++];\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\n\t\t\t\tvar qos = (messageInfo >> 1) & 0x03;\n\n\t\t\t\tvar len = readUint16(input, pos);\n\t\t\t\tpos += 2;\n\t\t\t\tvar topicName = parseUTF8(input, pos, len);\n\t\t\t\tpos += len;\n\t\t\t\t// If QoS 1 or 2 there will be a messageIdentifier\n\t\t\t\tif (qos > 0) {\n\t\t\t\t\twireMessage.messageIdentifier = readUint16(input, pos);\n\t\t\t\t\tpos += 2;\n\t\t\t\t}\n\n\t\t\t\tvar message = new Message(input.subarray(pos, endPos));\n\t\t\t\tif ((messageInfo & 0x01) == 0x01)\n\t\t\t\t\tmessage.retained = true;\n\t\t\t\tif ((messageInfo & 0x08) == 0x08)\n\t\t\t\t\tmessage.duplicate =  true;\n\t\t\t\tmessage.qos = qos;\n\t\t\t\tmessage.destinationName = topicName;\n\t\t\t\twireMessage.payloadMessage = message;\n\t\t\t\tbreak;\n\n\t\t\tcase  MESSAGE_TYPE.PUBACK:\n\t\t\tcase  MESSAGE_TYPE.PUBREC:\n\t\t\tcase  MESSAGE_TYPE.PUBREL:\n\t\t\tcase  MESSAGE_TYPE.PUBCOMP:\n\t\t\tcase  MESSAGE_TYPE.UNSUBACK:\n\t\t\t\twireMessage.messageIdentifier = readUint16(input, pos);\n\t\t\t\tbreak;\n\n\t\t\tcase  MESSAGE_TYPE.SUBACK:\n\t\t\t\twireMessage.messageIdentifier = readUint16(input, pos);\n\t\t\t\tpos += 2;\n\t\t\t\twireMessage.returnCode = input.subarray(pos, endPos);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn [wireMessage,endPos];\n\t\t}\n\n\t\tfunction writeUint16(input, buffer, offset) {\n\t\t\tbuffer[offset++] = input >> 8;      //MSB\n\t\t\tbuffer[offset++] = input % 256;     //LSB\n\t\t\treturn offset;\n\t\t}\n\n\t\tfunction writeString(input, utf8Length, buffer, offset) {\n\t\t\toffset = writeUint16(utf8Length, buffer, offset);\n\t\t\tstringToUTF8(input, buffer, offset);\n\t\t\treturn offset + utf8Length;\n\t\t}\n\n\t\tfunction readUint16(buffer, offset) {\n\t\t\treturn 256*buffer[offset] + buffer[offset+1];\n\t\t}\n\n\t\t/**\n\t * Encodes an MQTT Multi-Byte Integer\n\t * @private\n\t */\n\t\tfunction encodeMBI(number) {\n\t\t\tvar output = new Array(1);\n\t\t\tvar numBytes = 0;\n\n\t\t\tdo {\n\t\t\t\tvar digit = number % 128;\n\t\t\t\tnumber = number >> 7;\n\t\t\t\tif (number > 0) {\n\t\t\t\t\tdigit |= 0x80;\n\t\t\t\t}\n\t\t\t\toutput[numBytes++] = digit;\n\t\t\t} while ( (number > 0) && (numBytes<4) );\n\n\t\t\treturn output;\n\t\t}\n\n\t\t/**\n\t * Takes a String and calculates its length in bytes when encoded in UTF8.\n\t * @private\n\t */\n\t\tfunction UTF8Length(input) {\n\t\t\tvar output = 0;\n\t\t\tfor (var i = 0; i<input.length; i++)\n\t\t\t{\n\t\t\t\tvar charCode = input.charCodeAt(i);\n\t\t\t\tif (charCode > 0x7FF)\n\t\t\t\t{\n\t\t\t\t\t// Surrogate pair means its a 4 byte character\n\t\t\t\t\tif (0xD800 <= charCode && charCode <= 0xDBFF)\n\t\t\t\t\t{\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\toutput++;\n\t\t\t\t\t}\n\t\t\t\t\toutput +=3;\n\t\t\t\t}\n\t\t\t\telse if (charCode > 0x7F)\n\t\t\t\t\toutput +=2;\n\t\t\t\telse\n\t\t\t\t\toutput++;\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\n\t\t/**\n\t * Takes a String and writes it into an array as UTF8 encoded bytes.\n\t * @private\n\t */\n\t\tfunction stringToUTF8(input, output, start) {\n\t\t\tvar pos = start;\n\t\t\tfor (var i = 0; i<input.length; i++) {\n\t\t\t\tvar charCode = input.charCodeAt(i);\n\n\t\t\t\t// Check for a surrogate pair.\n\t\t\t\tif (0xD800 <= charCode && charCode <= 0xDBFF) {\n\t\t\t\t\tvar lowCharCode = input.charCodeAt(++i);\n\t\t\t\t\tif (isNaN(lowCharCode)) {\n\t\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UNICODE, [charCode, lowCharCode]));\n\t\t\t\t\t}\n\t\t\t\t\tcharCode = ((charCode - 0xD800)<<10) + (lowCharCode - 0xDC00) + 0x10000;\n\n\t\t\t\t}\n\n\t\t\t\tif (charCode <= 0x7F) {\n\t\t\t\t\toutput[pos++] = charCode;\n\t\t\t\t} else if (charCode <= 0x7FF) {\n\t\t\t\t\toutput[pos++] = charCode>>6  & 0x1F | 0xC0;\n\t\t\t\t\toutput[pos++] = charCode     & 0x3F | 0x80;\n\t\t\t\t} else if (charCode <= 0xFFFF) {\n\t\t\t\t\toutput[pos++] = charCode>>12 & 0x0F | 0xE0;\n\t\t\t\t\toutput[pos++] = charCode>>6  & 0x3F | 0x80;\n\t\t\t\t\toutput[pos++] = charCode     & 0x3F | 0x80;\n\t\t\t\t} else {\n\t\t\t\t\toutput[pos++] = charCode>>18 & 0x07 | 0xF0;\n\t\t\t\t\toutput[pos++] = charCode>>12 & 0x3F | 0x80;\n\t\t\t\t\toutput[pos++] = charCode>>6  & 0x3F | 0x80;\n\t\t\t\t\toutput[pos++] = charCode     & 0x3F | 0x80;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\n\t\tfunction parseUTF8(input, offset, length) {\n\t\t\tvar output = \"\";\n\t\t\tvar utf16;\n\t\t\tvar pos = offset;\n\n\t\t\twhile (pos < offset+length)\n\t\t\t{\n\t\t\t\tvar byte1 = input[pos++];\n\t\t\t\tif (byte1 < 128)\n\t\t\t\t\tutf16 = byte1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar byte2 = input[pos++]-128;\n\t\t\t\t\tif (byte2 < 0)\n\t\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16),\"\"]));\n\t\t\t\t\tif (byte1 < 0xE0)             // 2 byte character\n\t\t\t\t\t\tutf16 = 64*(byte1-0xC0) + byte2;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar byte3 = input[pos++]-128;\n\t\t\t\t\t\tif (byte3 < 0)\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16)]));\n\t\t\t\t\t\tif (byte1 < 0xF0)        // 3 byte character\n\t\t\t\t\t\t\tutf16 = 4096*(byte1-0xE0) + 64*byte2 + byte3;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar byte4 = input[pos++]-128;\n\t\t\t\t\t\t\tif (byte4 < 0)\n\t\t\t\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\n\t\t\t\t\t\t\tif (byte1 < 0xF8)        // 4 byte character\n\t\t\t\t\t\t\t\tutf16 = 262144*(byte1-0xF0) + 4096*byte2 + 64*byte3 + byte4;\n\t\t\t\t\t\t\telse                     // longer encodings are not supported\n\t\t\t\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (utf16 > 0xFFFF)   // 4 byte character - express as a surrogate pair\n\t\t\t\t{\n\t\t\t\t\tutf16 -= 0x10000;\n\t\t\t\t\toutput += String.fromCharCode(0xD800 + (utf16 >> 10)); // lead character\n\t\t\t\t\tutf16 = 0xDC00 + (utf16 & 0x3FF);  // trail character\n\t\t\t\t}\n\t\t\t\toutput += String.fromCharCode(utf16);\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\n\t\t/**\n\t * Repeat keepalive requests, monitor responses.\n\t * @ignore\n\t */\n\t\tvar Pinger = function(client, keepAliveInterval) {\n\t\t\tthis._client = client;\n\t\t\tthis._keepAliveInterval = keepAliveInterval*1000;\n\t\t\tthis.isReset = false;\n\n\t\t\tvar pingReq = new WireMessage(MESSAGE_TYPE.PINGREQ).encode();\n\n\t\t\tvar doTimeout = function (pinger) {\n\t\t\t\treturn function () {\n\t\t\t\t\treturn doPing.apply(pinger);\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t/** @ignore */\n\t\t\tvar doPing = function() {\n\t\t\t\tif (!this.isReset) {\n\t\t\t\t\tthis._client._trace(\"Pinger.doPing\", \"Timed out\");\n\t\t\t\t\tthis._client._disconnected( ERROR.PING_TIMEOUT.code , format(ERROR.PING_TIMEOUT));\n\t\t\t\t} else {\n\t\t\t\t\tthis.isReset = false;\n\t\t\t\t\tthis._client._trace(\"Pinger.doPing\", \"send PINGREQ\");\n\t\t\t\t\tthis._client.socket.send(pingReq);\n\t\t\t\t\tthis.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.reset = function() {\n\t\t\t\tthis.isReset = true;\n\t\t\t\tclearTimeout(this.timeout);\n\t\t\t\tif (this._keepAliveInterval > 0)\n\t\t\t\t\tthis.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);\n\t\t\t};\n\n\t\t\tthis.cancel = function() {\n\t\t\t\tclearTimeout(this.timeout);\n\t\t\t};\n\t\t};\n\n\t\t/**\n\t * Monitor request completion.\n\t * @ignore\n\t */\n\t\tvar Timeout = function(client, timeoutSeconds, action, args) {\n\t\t\tif (!timeoutSeconds)\n\t\t\t\ttimeoutSeconds = 30;\n\n\t\t\tvar doTimeout = function (action, client, args) {\n\t\t\t\treturn function () {\n\t\t\t\t\treturn action.apply(client, args);\n\t\t\t\t};\n\t\t\t};\n\t\t\tthis.timeout = setTimeout(doTimeout(action, client, args), timeoutSeconds * 1000);\n\n\t\t\tthis.cancel = function() {\n\t\t\t\tclearTimeout(this.timeout);\n\t\t\t};\n\t\t};\n\n\t/**\n\t * Internal implementation of the Websockets MQTT V3.1 client.\n\t *\n\t * @name Paho.ClientImpl @constructor\n\t * @param {String} host the DNS nameof the webSocket host.\n\t * @param {Number} port the port number for that host.\n\t * @param {String} clientId the MQ client identifier.\n\t */\n\t\tvar ClientImpl = function (uri, host, port, path, clientId) {\n\t\t// Check dependencies are satisfied in this browser.\n\t\t\tif (!(\"WebSocket\" in global && global.WebSocket !== null)) {\n\t\t\t\tthrow new Error(format(ERROR.UNSUPPORTED, [\"WebSocket\"]));\n\t\t\t}\n\t\t\tif (!(\"ArrayBuffer\" in global && global.ArrayBuffer !== null)) {\n\t\t\t\tthrow new Error(format(ERROR.UNSUPPORTED, [\"ArrayBuffer\"]));\n\t\t\t}\n\t\t\tthis._trace(\"Paho.Client\", uri, host, port, path, clientId);\n\n\t\t\tthis.host = host;\n\t\t\tthis.port = port;\n\t\t\tthis.path = path;\n\t\t\tthis.uri = uri;\n\t\t\tthis.clientId = clientId;\n\t\t\tthis._wsuri = null;\n\n\t\t\t// Local storagekeys are qualified with the following string.\n\t\t\t// The conditional inclusion of path in the key is for backward\n\t\t\t// compatibility to when the path was not configurable and assumed to\n\t\t\t// be /mqtt\n\t\t\tthis._localKey=host+\":\"+port+(path!=\"/mqtt\"?\":\"+path:\"\")+\":\"+clientId+\":\";\n\n\t\t\t// Create private instance-only message queue\n\t\t\t// Internal queue of messages to be sent, in sending order.\n\t\t\tthis._msg_queue = [];\n\t\t\tthis._buffered_msg_queue = [];\n\n\t\t\t// Messages we have sent and are expecting a response for, indexed by their respective message ids.\n\t\t\tthis._sentMessages = {};\n\n\t\t\t// Messages we have received and acknowleged and are expecting a confirm message for\n\t\t\t// indexed by their respective message ids.\n\t\t\tthis._receivedMessages = {};\n\n\t\t\t// Internal list of callbacks to be executed when messages\n\t\t\t// have been successfully sent over web socket, e.g. disconnect\n\t\t\t// when it doesn't have to wait for ACK, just message is dispatched.\n\t\t\tthis._notify_msg_sent = {};\n\n\t\t\t// Unique identifier for SEND messages, incrementing\n\t\t\t// counter as messages are sent.\n\t\t\tthis._message_identifier = 1;\n\n\t\t\t// Used to determine the transmission sequence of stored sent messages.\n\t\t\tthis._sequence = 0;\n\n\n\t\t\t// Load the local state, if any, from the saved version, only restore state relevant to this client.\n\t\t\tfor (var key in localStorage)\n\t\t\t\tif (   key.indexOf(\"Sent:\"+this._localKey) === 0 || key.indexOf(\"Received:\"+this._localKey) === 0)\n\t\t\t\t\tthis.restore(key);\n\t\t};\n\n\t\t// Messaging Client public instance members.\n\t\tClientImpl.prototype.host = null;\n\t\tClientImpl.prototype.port = null;\n\t\tClientImpl.prototype.path = null;\n\t\tClientImpl.prototype.uri = null;\n\t\tClientImpl.prototype.clientId = null;\n\n\t\t// Messaging Client private instance members.\n\t\tClientImpl.prototype.socket = null;\n\t\t/* true once we have received an acknowledgement to a CONNECT packet. */\n\t\tClientImpl.prototype.connected = false;\n\t\t/* The largest message identifier allowed, may not be larger than 2**16 but\n\t\t * if set smaller reduces the maximum number of outbound messages allowed.\n\t\t */\n\t\tClientImpl.prototype.maxMessageIdentifier = 65536;\n\t\tClientImpl.prototype.connectOptions = null;\n\t\tClientImpl.prototype.hostIndex = null;\n\t\tClientImpl.prototype.onConnected = null;\n\t\tClientImpl.prototype.onConnectionLost = null;\n\t\tClientImpl.prototype.onMessageDelivered = null;\n\t\tClientImpl.prototype.onMessageArrived = null;\n\t\tClientImpl.prototype.traceFunction = null;\n\t\tClientImpl.prototype._msg_queue = null;\n\t\tClientImpl.prototype._buffered_msg_queue = null;\n\t\tClientImpl.prototype._connectTimeout = null;\n\t\t/* The sendPinger monitors how long we allow before we send data to prove to the server that we are alive. */\n\t\tClientImpl.prototype.sendPinger = null;\n\t\t/* The receivePinger monitors how long we allow before we require evidence that the server is alive. */\n\t\tClientImpl.prototype.receivePinger = null;\n\t\tClientImpl.prototype._reconnectInterval = 1; // Reconnect Delay, starts at 1 second\n\t\tClientImpl.prototype._reconnecting = false;\n\t\tClientImpl.prototype._reconnectTimeout = null;\n\t\tClientImpl.prototype.disconnectedPublishing = false;\n\t\tClientImpl.prototype.disconnectedBufferSize = 5000;\n\n\t\tClientImpl.prototype.receiveBuffer = null;\n\n\t\tClientImpl.prototype._traceBuffer = null;\n\t\tClientImpl.prototype._MAX_TRACE_ENTRIES = 100;\n\n\t\tClientImpl.prototype.connect = function (connectOptions) {\n\t\t\tvar connectOptionsMasked = this._traceMask(connectOptions, \"password\");\n\t\t\tthis._trace(\"Client.connect\", connectOptionsMasked, this.socket, this.connected);\n\n\t\t\tif (this.connected)\n\t\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\n\t\t\tif (this.socket)\n\t\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\n\n\t\t\tif (this._reconnecting) {\n\t\t\t// connect() function is called while reconnect is in progress.\n\t\t\t// Terminate the auto reconnect process to use new connect options.\n\t\t\t\tthis._reconnectTimeout.cancel();\n\t\t\t\tthis._reconnectTimeout = null;\n\t\t\t\tthis._reconnecting = false;\n\t\t\t}\n\n\t\t\tthis.connectOptions = connectOptions;\n\t\t\tthis._reconnectInterval = 1;\n\t\t\tthis._reconnecting = false;\n\t\t\tif (connectOptions.uris) {\n\t\t\t\tthis.hostIndex = 0;\n\t\t\t\tthis._doConnect(connectOptions.uris[0]);\n\t\t\t} else {\n\t\t\t\tthis._doConnect(this.uri);\n\t\t\t}\n\n\t\t};\n\n\t\tClientImpl.prototype.subscribe = function (filter, subscribeOptions) {\n\t\t\tthis._trace(\"Client.subscribe\", filter, subscribeOptions);\n\n\t\t\tif (!this.connected)\n\t\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n\n            var wireMessage = new WireMessage(MESSAGE_TYPE.SUBSCRIBE);\n            wireMessage.topics = filter.constructor === Array ? filter : [filter];\n            if (subscribeOptions.qos === undefined)\n                subscribeOptions.qos = 0;\n            wireMessage.requestedQos = [];\n            for (var i = 0; i < wireMessage.topics.length; i++)\n                wireMessage.requestedQos[i] = subscribeOptions.qos;\n\n\t\t\tif (subscribeOptions.onSuccess) {\n\t\t\t\twireMessage.onSuccess = function(grantedQos) {subscribeOptions.onSuccess({invocationContext:subscribeOptions.invocationContext,grantedQos:grantedQos});};\n\t\t\t}\n\n\t\t\tif (subscribeOptions.onFailure) {\n\t\t\t\twireMessage.onFailure = function(errorCode) {subscribeOptions.onFailure({invocationContext:subscribeOptions.invocationContext,errorCode:errorCode, errorMessage:format(errorCode)});};\n\t\t\t}\n\n\t\t\tif (subscribeOptions.timeout) {\n\t\t\t\twireMessage.timeOut = new Timeout(this, subscribeOptions.timeout, subscribeOptions.onFailure,\n\t\t\t\t\t[{invocationContext:subscribeOptions.invocationContext,\n\t\t\t\t\t\terrorCode:ERROR.SUBSCRIBE_TIMEOUT.code,\n\t\t\t\t\t\terrorMessage:format(ERROR.SUBSCRIBE_TIMEOUT)}]);\n\t\t\t}\n\n\t\t\t// All subscriptions return a SUBACK.\n\t\t\tthis._requires_ack(wireMessage);\n\t\t\tthis._schedule_message(wireMessage);\n\t\t};\n\n\t\t/** @ignore */\n\t\tClientImpl.prototype.unsubscribe = function(filter, unsubscribeOptions) {\n\t\t\tthis._trace(\"Client.unsubscribe\", filter, unsubscribeOptions);\n\n\t\t\tif (!this.connected)\n\t\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n\n            var wireMessage = new WireMessage(MESSAGE_TYPE.UNSUBSCRIBE);\n            wireMessage.topics = filter.constructor === Array ? filter : [filter];\n\n\t\t\tif (unsubscribeOptions.onSuccess) {\n\t\t\t\twireMessage.callback = function() {unsubscribeOptions.onSuccess({invocationContext:unsubscribeOptions.invocationContext});};\n\t\t\t}\n\t\t\tif (unsubscribeOptions.timeout) {\n\t\t\t\twireMessage.timeOut = new Timeout(this, unsubscribeOptions.timeout, unsubscribeOptions.onFailure,\n\t\t\t\t\t[{invocationContext:unsubscribeOptions.invocationContext,\n\t\t\t\t\t\terrorCode:ERROR.UNSUBSCRIBE_TIMEOUT.code,\n\t\t\t\t\t\terrorMessage:format(ERROR.UNSUBSCRIBE_TIMEOUT)}]);\n\t\t\t}\n\n\t\t\t// All unsubscribes return a SUBACK.\n\t\t\tthis._requires_ack(wireMessage);\n\t\t\tthis._schedule_message(wireMessage);\n\t\t};\n\n\t\tClientImpl.prototype.send = function (message) {\n\t\t\tthis._trace(\"Client.send\", message);\n\n\t\t\tvar wireMessage = new WireMessage(MESSAGE_TYPE.PUBLISH);\n\t\t\twireMessage.payloadMessage = message;\n\n\t\t\tif (this.connected) {\n\t\t\t// Mark qos 1 & 2 message as \"ACK required\"\n\t\t\t// For qos 0 message, invoke onMessageDelivered callback if there is one.\n\t\t\t// Then schedule the message.\n\t\t\t\tif (message.qos > 0) {\n\t\t\t\t\tthis._requires_ack(wireMessage);\n\t\t\t\t} else if (this.onMessageDelivered) {\n\t\t\t\t\tthis._notify_msg_sent[wireMessage] = this.onMessageDelivered(wireMessage.payloadMessage);\n\t\t\t\t}\n\t\t\t\tthis._schedule_message(wireMessage);\n\t\t\t} else {\n\t\t\t// Currently disconnected, will not schedule this message\n\t\t\t// Check if reconnecting is in progress and disconnected publish is enabled.\n\t\t\t\tif (this._reconnecting && this.disconnectedPublishing) {\n\t\t\t\t// Check the limit which include the \"required ACK\" messages\n\t\t\t\t\tvar messageCount = Object.keys(this._sentMessages).length + this._buffered_msg_queue.length;\n\t\t\t\t\tif (messageCount > this.disconnectedBufferSize) {\n\t\t\t\t\t\tthrow new Error(format(ERROR.BUFFER_FULL, [this.disconnectedBufferSize]));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (message.qos > 0) {\n\t\t\t\t\t\t// Mark this message as \"ACK required\"\n\t\t\t\t\t\t\tthis._requires_ack(wireMessage);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twireMessage.sequence = ++this._sequence;\n\t\t\t\t\t\t\t// Add messages in fifo order to array, by adding to start\n\t\t\t\t\t\t\tthis._buffered_msg_queue.unshift(wireMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tClientImpl.prototype.disconnect = function () {\n\t\t\tthis._trace(\"Client.disconnect\");\n\n\t\t\tif (this._reconnecting) {\n\t\t\t// disconnect() function is called while reconnect is in progress.\n\t\t\t// Terminate the auto reconnect process.\n\t\t\t\tthis._reconnectTimeout.cancel();\n\t\t\t\tthis._reconnectTimeout = null;\n\t\t\t\tthis._reconnecting = false;\n\t\t\t}\n\n\t\t\tif (!this.socket)\n\t\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"not connecting or connected\"]));\n\n\t\t\tvar wireMessage = new WireMessage(MESSAGE_TYPE.DISCONNECT);\n\n\t\t\t// Run the disconnected call back as soon as the message has been sent,\n\t\t\t// in case of a failure later on in the disconnect processing.\n\t\t\t// as a consequence, the _disconected call back may be run several times.\n\t\t\tthis._notify_msg_sent[wireMessage] = scope(this._disconnected, this);\n\n\t\t\tthis._schedule_message(wireMessage);\n\t\t};\n\n\t\tClientImpl.prototype.getTraceLog = function () {\n\t\t\tif ( this._traceBuffer !== null ) {\n\t\t\t\tthis._trace(\"Client.getTraceLog\", new Date());\n\t\t\t\tthis._trace(\"Client.getTraceLog in flight messages\", this._sentMessages.length);\n\t\t\t\tfor (var key in this._sentMessages)\n\t\t\t\t\tthis._trace(\"_sentMessages \",key, this._sentMessages[key]);\n\t\t\t\tfor (var key in this._receivedMessages)\n\t\t\t\t\tthis._trace(\"_receivedMessages \",key, this._receivedMessages[key]);\n\n\t\t\t\treturn this._traceBuffer;\n\t\t\t}\n\t\t};\n\n\t\tClientImpl.prototype.startTrace = function () {\n\t\t\tif ( this._traceBuffer === null ) {\n\t\t\t\tthis._traceBuffer = [];\n\t\t\t}\n\t\t\tthis._trace(\"Client.startTrace\", new Date(), version);\n\t\t};\n\n\t\tClientImpl.prototype.stopTrace = function () {\n\t\t\tdelete this._traceBuffer;\n\t\t};\n\n\t\tClientImpl.prototype._doConnect = function (wsurl) {\n\t\t// When the socket is open, this client will send the CONNECT WireMessage using the saved parameters.\n\t\t\tif (this.connectOptions.useSSL) {\n\t\t\t\tvar uriParts = wsurl.split(\":\");\n\t\t\t\turiParts[0] = \"wss\";\n\t\t\t\twsurl = uriParts.join(\":\");\n\t\t\t}\n\t\t\tthis._wsuri = wsurl;\n\t\t\tthis.connected = false;\n\n\n\n\t\t\tif (this.connectOptions.mqttVersion < 4) {\n\t\t\t\tthis.socket = new WebSocket(wsurl, [\"mqttv3.1\"]);\n\t\t\t} else {\n\t\t\t\tthis.socket = new WebSocket(wsurl, [\"mqtt\"]);\n\t\t\t}\n\t\t\tthis.socket.binaryType = \"arraybuffer\";\n\t\t\tthis.socket.onopen = scope(this._on_socket_open, this);\n\t\t\tthis.socket.onmessage = scope(this._on_socket_message, this);\n\t\t\tthis.socket.onerror = scope(this._on_socket_error, this);\n\t\t\tthis.socket.onclose = scope(this._on_socket_close, this);\n\n\t\t\tthis.sendPinger = new Pinger(this, this.connectOptions.keepAliveInterval);\n\t\t\tthis.receivePinger = new Pinger(this, this.connectOptions.keepAliveInterval);\n\t\t\tif (this._connectTimeout) {\n\t\t\t\tthis._connectTimeout.cancel();\n\t\t\t\tthis._connectTimeout = null;\n\t\t\t}\n\t\t\tthis._connectTimeout = new Timeout(this, this.connectOptions.timeout, this._disconnected,  [ERROR.CONNECT_TIMEOUT.code, format(ERROR.CONNECT_TIMEOUT)]);\n\t\t};\n\n\n\t\t// Schedule a new message to be sent over the WebSockets\n\t\t// connection. CONNECT messages cause WebSocket connection\n\t\t// to be started. All other messages are queued internally\n\t\t// until this has happened. When WS connection starts, process\n\t\t// all outstanding messages.\n\t\tClientImpl.prototype._schedule_message = function (message) {\n\t\t\t// Add messages in fifo order to array, by adding to start\n\t\t\tthis._msg_queue.unshift(message);\n\t\t\t// Process outstanding messages in the queue if we have an  open socket, and have received CONNACK.\n\t\t\tif (this.connected) {\n\t\t\t\tthis._process_queue();\n\t\t\t}\n\t\t};\n\n\t\tClientImpl.prototype.store = function(prefix, wireMessage) {\n\t\t\tvar storedMessage = {type:wireMessage.type, messageIdentifier:wireMessage.messageIdentifier, version:1};\n\n\t\t\tswitch(wireMessage.type) {\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\n\t\t\t\tif(wireMessage.pubRecReceived)\n\t\t\t\t\tstoredMessage.pubRecReceived = true;\n\n\t\t\t\t// Convert the payload to a hex string.\n\t\t\t\tstoredMessage.payloadMessage = {};\n\t\t\t\tvar hex = \"\";\n\t\t\t\tvar messageBytes = wireMessage.payloadMessage.payloadBytes;\n\t\t\t\tfor (var i=0; i<messageBytes.length; i++) {\n\t\t\t\t\tif (messageBytes[i] <= 0xF)\n\t\t\t\t\t\thex = hex+\"0\"+messageBytes[i].toString(16);\n\t\t\t\t\telse\n\t\t\t\t\t\thex = hex+messageBytes[i].toString(16);\n\t\t\t\t}\n\t\t\t\tstoredMessage.payloadMessage.payloadHex = hex;\n\n\t\t\t\tstoredMessage.payloadMessage.qos = wireMessage.payloadMessage.qos;\n\t\t\t\tstoredMessage.payloadMessage.destinationName = wireMessage.payloadMessage.destinationName;\n\t\t\t\tif (wireMessage.payloadMessage.duplicate)\n\t\t\t\t\tstoredMessage.payloadMessage.duplicate = true;\n\t\t\t\tif (wireMessage.payloadMessage.retained)\n\t\t\t\t\tstoredMessage.payloadMessage.retained = true;\n\n\t\t\t\t// Add a sequence number to sent messages.\n\t\t\t\tif ( prefix.indexOf(\"Sent:\") === 0 ) {\n\t\t\t\t\tif ( wireMessage.sequence === undefined )\n\t\t\t\t\t\twireMessage.sequence = ++this._sequence;\n\t\t\t\t\tstoredMessage.sequence = wireMessage.sequence;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow Error(format(ERROR.INVALID_STORED_DATA, [prefix+this._localKey+wireMessage.messageIdentifier, storedMessage]));\n\t\t\t}\n\t\t\tlocalStorage.setItem(prefix+this._localKey+wireMessage.messageIdentifier, JSON.stringify(storedMessage));\n\t\t};\n\n\t\tClientImpl.prototype.restore = function(key) {\n\t\t\tvar value = localStorage.getItem(key);\n\t\t\tvar storedMessage = JSON.parse(value);\n\n\t\t\tvar wireMessage = new WireMessage(storedMessage.type, storedMessage);\n\n\t\t\tswitch(storedMessage.type) {\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\n\t\t\t\t// Replace the payload message with a Message object.\n\t\t\t\tvar hex = storedMessage.payloadMessage.payloadHex;\n\t\t\t\tvar buffer = new ArrayBuffer((hex.length)/2);\n\t\t\t\tvar byteStream = new Uint8Array(buffer);\n\t\t\t\tvar i = 0;\n\t\t\t\twhile (hex.length >= 2) {\n\t\t\t\t\tvar x = parseInt(hex.substring(0, 2), 16);\n\t\t\t\t\thex = hex.substring(2, hex.length);\n\t\t\t\t\tbyteStream[i++] = x;\n\t\t\t\t}\n\t\t\t\tvar payloadMessage = new Message(byteStream);\n\n\t\t\t\tpayloadMessage.qos = storedMessage.payloadMessage.qos;\n\t\t\t\tpayloadMessage.destinationName = storedMessage.payloadMessage.destinationName;\n\t\t\t\tif (storedMessage.payloadMessage.duplicate)\n\t\t\t\t\tpayloadMessage.duplicate = true;\n\t\t\t\tif (storedMessage.payloadMessage.retained)\n\t\t\t\t\tpayloadMessage.retained = true;\n\t\t\t\twireMessage.payloadMessage = payloadMessage;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow Error(format(ERROR.INVALID_STORED_DATA, [key, value]));\n\t\t\t}\n\n\t\t\tif (key.indexOf(\"Sent:\"+this._localKey) === 0) {\n\t\t\t\twireMessage.payloadMessage.duplicate = true;\n\t\t\t\tthis._sentMessages[wireMessage.messageIdentifier] = wireMessage;\n\t\t\t} else if (key.indexOf(\"Received:\"+this._localKey) === 0) {\n\t\t\t\tthis._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\n\t\t\t}\n\t\t};\n\n\t\tClientImpl.prototype._process_queue = function () {\n\t\t\tvar message = null;\n\n\t\t\t// Send all queued messages down socket connection\n\t\t\twhile ((message = this._msg_queue.pop())) {\n\t\t\t\tthis._socket_send(message);\n\t\t\t\t// Notify listeners that message was successfully sent\n\t\t\t\tif (this._notify_msg_sent[message]) {\n\t\t\t\t\tthis._notify_msg_sent[message]();\n\t\t\t\t\tdelete this._notify_msg_sent[message];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t * Expect an ACK response for this message. Add message to the set of in progress\n\t * messages and set an unused identifier in this message.\n\t * @ignore\n\t */\n\t\tClientImpl.prototype._requires_ack = function (wireMessage) {\n\t\t\tvar messageCount = Object.keys(this._sentMessages).length;\n\t\t\tif (messageCount > this.maxMessageIdentifier)\n\t\t\t\tthrow Error (\"Too many messages:\"+messageCount);\n\n\t\t\twhile(this._sentMessages[this._message_identifier] !== undefined) {\n\t\t\t\tthis._message_identifier++;\n\t\t\t}\n\t\t\twireMessage.messageIdentifier = this._message_identifier;\n\t\t\tthis._sentMessages[wireMessage.messageIdentifier] = wireMessage;\n\t\t\tif (wireMessage.type === MESSAGE_TYPE.PUBLISH) {\n\t\t\t\tthis.store(\"Sent:\", wireMessage);\n\t\t\t}\n\t\t\tif (this._message_identifier === this.maxMessageIdentifier) {\n\t\t\t\tthis._message_identifier = 1;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t * Called when the underlying websocket has been opened.\n\t * @ignore\n\t */\n\t\tClientImpl.prototype._on_socket_open = function () {\n\t\t// Create the CONNECT message object.\n\t\t\tvar wireMessage = new WireMessage(MESSAGE_TYPE.CONNECT, this.connectOptions);\n\t\t\twireMessage.clientId = this.clientId;\n\t\t\tthis._socket_send(wireMessage);\n\t\t};\n\n\t\t/**\n\t * Called when the underlying websocket has received a complete packet.\n\t * @ignore\n\t */\n\t\tClientImpl.prototype._on_socket_message = function (event) {\n\t\t\tthis._trace(\"Client._on_socket_message\", event.data);\n\t\t\tvar messages = this._deframeMessages(event.data);\n\t\t\tfor (var i = 0; i < messages.length; i+=1) {\n\t\t\t\tthis._handleMessage(messages[i]);\n\t\t\t}\n\t\t};\n\n\t\tClientImpl.prototype._deframeMessages = function(data) {\n\t\t\tvar byteArray = new Uint8Array(data);\n\t\t\tvar messages = [];\n\t\t\tif (this.receiveBuffer) {\n\t\t\t\tvar newData = new Uint8Array(this.receiveBuffer.length+byteArray.length);\n\t\t\t\tnewData.set(this.receiveBuffer);\n\t\t\t\tnewData.set(byteArray,this.receiveBuffer.length);\n\t\t\t\tbyteArray = newData;\n\t\t\t\tdelete this.receiveBuffer;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tvar offset = 0;\n\t\t\t\twhile(offset < byteArray.length) {\n\t\t\t\t\tvar result = decodeMessage(byteArray,offset);\n\t\t\t\t\tvar wireMessage = result[0];\n\t\t\t\t\toffset = result[1];\n\t\t\t\t\tif (wireMessage !== null) {\n\t\t\t\t\t\tmessages.push(wireMessage);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (offset < byteArray.length) {\n\t\t\t\t\tthis.receiveBuffer = byteArray.subarray(offset);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tvar errorStack = ((error.hasOwnProperty(\"stack\") == \"undefined\") ? error.stack.toString() : \"No Error Stack Available\");\n\t\t\t\tthis._disconnected(ERROR.INTERNAL_ERROR.code , format(ERROR.INTERNAL_ERROR, [error.message,errorStack]));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn messages;\n\t\t};\n\n\t\tClientImpl.prototype._handleMessage = function(wireMessage) {\n\n\t\t\tthis._trace(\"Client._handleMessage\", wireMessage);\n\n\t\t\ttry {\n\t\t\t\tswitch(wireMessage.type) {\n\t\t\t\tcase MESSAGE_TYPE.CONNACK:\n\t\t\t\t\tthis._connectTimeout.cancel();\n\t\t\t\t\tif (this._reconnectTimeout)\n\t\t\t\t\t\tthis._reconnectTimeout.cancel();\n\n\t\t\t\t\t// If we have started using clean session then clear up the local state.\n\t\t\t\t\tif (this.connectOptions.cleanSession) {\n\t\t\t\t\t\tfor (var key in this._sentMessages) {\n\t\t\t\t\t\t\tvar sentMessage = this._sentMessages[key];\n\t\t\t\t\t\t\tlocalStorage.removeItem(\"Sent:\"+this._localKey+sentMessage.messageIdentifier);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._sentMessages = {};\n\n\t\t\t\t\t\tfor (var key in this._receivedMessages) {\n\t\t\t\t\t\t\tvar receivedMessage = this._receivedMessages[key];\n\t\t\t\t\t\t\tlocalStorage.removeItem(\"Received:\"+this._localKey+receivedMessage.messageIdentifier);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._receivedMessages = {};\n\t\t\t\t\t}\n\t\t\t\t\t// Client connected and ready for business.\n\t\t\t\t\tif (wireMessage.returnCode === 0) {\n\n\t\t\t\t\t\tthis.connected = true;\n\t\t\t\t\t\t// Jump to the end of the list of uris and stop looking for a good host.\n\n\t\t\t\t\t\tif (this.connectOptions.uris)\n\t\t\t\t\t\t\tthis.hostIndex = this.connectOptions.uris.length;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._disconnected(ERROR.CONNACK_RETURNCODE.code , format(ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, CONNACK_RC[wireMessage.returnCode]]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Resend messages.\n\t\t\t\t\tvar sequencedMessages = [];\n\t\t\t\t\tfor (var msgId in this._sentMessages) {\n\t\t\t\t\t\tif (this._sentMessages.hasOwnProperty(msgId))\n\t\t\t\t\t\t\tsequencedMessages.push(this._sentMessages[msgId]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Also schedule qos 0 buffered messages if any\n\t\t\t\t\tif (this._buffered_msg_queue.length > 0) {\n\t\t\t\t\t\tvar msg = null;\n\t\t\t\t\t\twhile ((msg = this._buffered_msg_queue.pop())) {\n\t\t\t\t\t\t\tsequencedMessages.push(msg);\n\t\t\t\t\t\t\tif (this.onMessageDelivered)\n\t\t\t\t\t\t\t\tthis._notify_msg_sent[msg] = this.onMessageDelivered(msg.payloadMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Sort sentMessages into the original sent order.\n\t\t\t\t\tvar sequencedMessages = sequencedMessages.sort(function(a,b) {return a.sequence - b.sequence;} );\n\t\t\t\t\tfor (var i=0, len=sequencedMessages.length; i<len; i++) {\n\t\t\t\t\t\tvar sentMessage = sequencedMessages[i];\n\t\t\t\t\t\tif (sentMessage.type == MESSAGE_TYPE.PUBLISH && sentMessage.pubRecReceived) {\n\t\t\t\t\t\t\tvar pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {messageIdentifier:sentMessage.messageIdentifier});\n\t\t\t\t\t\t\tthis._schedule_message(pubRelMessage);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._schedule_message(sentMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Execute the connectOptions.onSuccess callback if there is one.\n\t\t\t\t\t// Will also now return if this connection was the result of an automatic\n\t\t\t\t\t// reconnect and which URI was successfully connected to.\n\t\t\t\t\tif (this.connectOptions.onSuccess) {\n\t\t\t\t\t\tthis.connectOptions.onSuccess({invocationContext:this.connectOptions.invocationContext});\n\t\t\t\t\t}\n\n\t\t\t\t\tvar reconnected = false;\n\t\t\t\t\tif (this._reconnecting) {\n\t\t\t\t\t\treconnected = true;\n\t\t\t\t\t\tthis._reconnectInterval = 1;\n\t\t\t\t\t\tthis._reconnecting = false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Execute the onConnected callback if there is one.\n\t\t\t\t\tthis._connected(reconnected, this._wsuri);\n\n\t\t\t\t\t// Process all queued messages now that the connection is established.\n\t\t\t\t\tthis._process_queue();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MESSAGE_TYPE.PUBLISH:\n\t\t\t\t\tthis._receivePublish(wireMessage);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MESSAGE_TYPE.PUBACK:\n\t\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t\t// If this is a re flow of a PUBACK after we have restarted receivedMessage will not exist.\n\t\t\t\t\tif (sentMessage) {\n\t\t\t\t\t\tdelete this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t\t\tlocalStorage.removeItem(\"Sent:\"+this._localKey+wireMessage.messageIdentifier);\n\t\t\t\t\t\tif (this.onMessageDelivered)\n\t\t\t\t\t\t\tthis.onMessageDelivered(sentMessage.payloadMessage);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MESSAGE_TYPE.PUBREC:\n\t\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t\t// If this is a re flow of a PUBREC after we have restarted receivedMessage will not exist.\n\t\t\t\t\tif (sentMessage) {\n\t\t\t\t\t\tsentMessage.pubRecReceived = true;\n\t\t\t\t\t\tvar pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {messageIdentifier:wireMessage.messageIdentifier});\n\t\t\t\t\t\tthis.store(\"Sent:\", sentMessage);\n\t\t\t\t\t\tthis._schedule_message(pubRelMessage);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MESSAGE_TYPE.PUBREL:\n\t\t\t\t\tvar receivedMessage = this._receivedMessages[wireMessage.messageIdentifier];\n\t\t\t\t\tlocalStorage.removeItem(\"Received:\"+this._localKey+wireMessage.messageIdentifier);\n\t\t\t\t\t// If this is a re flow of a PUBREL after we have restarted receivedMessage will not exist.\n\t\t\t\t\tif (receivedMessage) {\n\t\t\t\t\t\tthis._receiveMessage(receivedMessage);\n\t\t\t\t\t\tdelete this._receivedMessages[wireMessage.messageIdentifier];\n\t\t\t\t\t}\n\t\t\t\t\t// Always flow PubComp, we may have previously flowed PubComp but the server lost it and restarted.\n\t\t\t\t\tvar pubCompMessage = new WireMessage(MESSAGE_TYPE.PUBCOMP, {messageIdentifier:wireMessage.messageIdentifier});\n\t\t\t\t\tthis._schedule_message(pubCompMessage);\n\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MESSAGE_TYPE.PUBCOMP:\n\t\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t\tdelete this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t\tlocalStorage.removeItem(\"Sent:\"+this._localKey+wireMessage.messageIdentifier);\n\t\t\t\t\tif (this.onMessageDelivered)\n\t\t\t\t\t\tthis.onMessageDelivered(sentMessage.payloadMessage);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MESSAGE_TYPE.SUBACK:\n\t\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t\tif (sentMessage) {\n\t\t\t\t\t\tif(sentMessage.timeOut)\n\t\t\t\t\t\t\tsentMessage.timeOut.cancel();\n\t\t\t\t\t\t// This will need to be fixed when we add multiple topic support\n\t\t\t\t\t\tif (wireMessage.returnCode[0] === 0x80) {\n\t\t\t\t\t\t\tif (sentMessage.onFailure) {\n\t\t\t\t\t\t\t\tsentMessage.onFailure(wireMessage.returnCode);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (sentMessage.onSuccess) {\n\t\t\t\t\t\t\tsentMessage.onSuccess(wireMessage.returnCode);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MESSAGE_TYPE.UNSUBACK:\n\t\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t\tif (sentMessage) {\n\t\t\t\t\t\tif (sentMessage.timeOut)\n\t\t\t\t\t\t\tsentMessage.timeOut.cancel();\n\t\t\t\t\t\tif (sentMessage.callback) {\n\t\t\t\t\t\t\tsentMessage.callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MESSAGE_TYPE.PINGRESP:\n\t\t\t\t/* The sendPinger or receivePinger may have sent a ping, the receivePinger has already been reset. */\n\t\t\t\t\tthis.sendPinger.reset();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MESSAGE_TYPE.DISCONNECT:\n\t\t\t\t// Clients do not expect to receive disconnect packets.\n\t\t\t\t\tthis._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code , format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code , format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tvar errorStack = ((error.hasOwnProperty(\"stack\") == \"undefined\") ? error.stack.toString() : \"No Error Stack Available\");\n\t\t\t\tthis._disconnected(ERROR.INTERNAL_ERROR.code , format(ERROR.INTERNAL_ERROR, [error.message,errorStack]));\n\t\t\t\treturn;\n\t\t\t}\n\t\t};\n\n\t\t/** @ignore */\n\t\tClientImpl.prototype._on_socket_error = function (error) {\n\t\t\tif (!this._reconnecting) {\n\t\t\t\tthis._disconnected(ERROR.SOCKET_ERROR.code , format(ERROR.SOCKET_ERROR, [error.data]));\n\t\t\t}\n\t\t};\n\n\t\t/** @ignore */\n\t\tClientImpl.prototype._on_socket_close = function () {\n\t\t\tif (!this._reconnecting) {\n\t\t\t\tthis._disconnected(ERROR.SOCKET_CLOSE.code , format(ERROR.SOCKET_CLOSE));\n\t\t\t}\n\t\t};\n\n\t\t/** @ignore */\n\t\tClientImpl.prototype._socket_send = function (wireMessage) {\n\n\t\t\tif (wireMessage.type == 1) {\n\t\t\t\tvar wireMessageMasked = this._traceMask(wireMessage, \"password\");\n\t\t\t\tthis._trace(\"Client._socket_send\", wireMessageMasked);\n\t\t\t}\n\t\t\telse this._trace(\"Client._socket_send\", wireMessage);\n\n\t\t\tthis.socket.send(wireMessage.encode());\n\t\t\t/* We have proved to the server we are alive. */\n\t\t\tthis.sendPinger.reset();\n\t\t};\n\n\t\t/** @ignore */\n\t\tClientImpl.prototype._receivePublish = function (wireMessage) {\n\t\t\tswitch(wireMessage.payloadMessage.qos) {\n\t\t\tcase \"undefined\":\n\t\t\tcase 0:\n\t\t\t\tthis._receiveMessage(wireMessage);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tvar pubAckMessage = new WireMessage(MESSAGE_TYPE.PUBACK, {messageIdentifier:wireMessage.messageIdentifier});\n\t\t\t\tthis._schedule_message(pubAckMessage);\n\t\t\t\tthis._receiveMessage(wireMessage);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tthis._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\n\t\t\t\tthis.store(\"Received:\", wireMessage);\n\t\t\t\tvar pubRecMessage = new WireMessage(MESSAGE_TYPE.PUBREC, {messageIdentifier:wireMessage.messageIdentifier});\n\t\t\t\tthis._schedule_message(pubRecMessage);\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow Error(\"Invaild qos=\" + wireMessage.payloadMessage.qos);\n\t\t\t}\n\t\t};\n\n\t\t/** @ignore */\n\t\tClientImpl.prototype._receiveMessage = function (wireMessage) {\n\t\t\tif (this.onMessageArrived) {\n\t\t\t\tthis.onMessageArrived(wireMessage.payloadMessage);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t * Client has connected.\n\t * @param {reconnect} [boolean] indicate if this was a result of reconnect operation.\n\t * @param {uri} [string] fully qualified WebSocket URI of the server.\n\t */\n\t\tClientImpl.prototype._connected = function (reconnect, uri) {\n\t\t// Execute the onConnected callback if there is one.\n\t\t\tif (this.onConnected)\n\t\t\t\tthis.onConnected(reconnect, uri);\n\t\t};\n\n\t\t/**\n\t * Attempts to reconnect the client to the server.\n   * For each reconnect attempt, will double the reconnect interval\n   * up to 128 seconds.\n\t */\n\t\tClientImpl.prototype._reconnect = function () {\n\t\t\tthis._trace(\"Client._reconnect\");\n\t\t\tif (!this.connected) {\n\t\t\t\tthis._reconnecting = true;\n\t\t\t\tthis.sendPinger.cancel();\n\t\t\t\tthis.receivePinger.cancel();\n\t\t\t\tif (this._reconnectInterval < 128)\n\t\t\t\t\tthis._reconnectInterval = this._reconnectInterval * 2;\n\t\t\t\tif (this.connectOptions.uris) {\n\t\t\t\t\tthis.hostIndex = 0;\n\t\t\t\t\tthis._doConnect(this.connectOptions.uris[0]);\n\t\t\t\t} else {\n\t\t\t\t\tthis._doConnect(this.uri);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t * Client has disconnected either at its own request or because the server\n\t * or network disconnected it. Remove all non-durable state.\n\t * @param {errorCode} [number] the error number.\n\t * @param {errorText} [string] the error text.\n\t * @ignore\n\t */\n\t\tClientImpl.prototype._disconnected = function (errorCode, errorText) {\n\t\t\tthis._trace(\"Client._disconnected\", errorCode, errorText);\n\n\t\t\tif (errorCode !== undefined && this._reconnecting) {\n\t\t\t\t//Continue automatic reconnect process\n\t\t\t\tthis._reconnectTimeout = new Timeout(this, this._reconnectInterval, this._reconnect);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.sendPinger.cancel();\n\t\t\tthis.receivePinger.cancel();\n\t\t\tif (this._connectTimeout) {\n\t\t\t\tthis._connectTimeout.cancel();\n\t\t\t\tthis._connectTimeout = null;\n\t\t\t}\n\n\t\t\t// Clear message buffers.\n\t\t\tthis._msg_queue = [];\n\t\t\tthis._buffered_msg_queue = [];\n\t\t\tthis._notify_msg_sent = {};\n\n\t\t\tif (this.socket) {\n\t\t\t// Cancel all socket callbacks so that they cannot be driven again by this socket.\n\t\t\t\tthis.socket.onopen = null;\n\t\t\t\tthis.socket.onmessage = null;\n\t\t\t\tthis.socket.onerror = null;\n\t\t\t\tthis.socket.onclose = null;\n\t\t\t\tif (this.socket.readyState === 1)\n\t\t\t\t\tthis.socket.close();\n\t\t\t\tdelete this.socket;\n\t\t\t}\n\n\t\t\tif (this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length-1) {\n\t\t\t// Try the next host.\n\t\t\t\tthis.hostIndex++;\n\t\t\t\tthis._doConnect(this.connectOptions.uris[this.hostIndex]);\n\t\t\t} else {\n\n\t\t\t\tif (errorCode === undefined) {\n\t\t\t\t\terrorCode = ERROR.OK.code;\n\t\t\t\t\terrorText = format(ERROR.OK);\n\t\t\t\t}\n\n\t\t\t\t// Run any application callbacks last as they may attempt to reconnect and hence create a new socket.\n\t\t\t\tif (this.connected) {\n\t\t\t\t\tthis.connected = false;\n\t\t\t\t\t// Execute the connectionLostCallback if there is one, and we were connected.\n\t\t\t\t\tif (this.onConnectionLost) {\n\t\t\t\t\t\tthis.onConnectionLost({errorCode:errorCode, errorMessage:errorText, reconnect:this.connectOptions.reconnect, uri:this._wsuri});\n\t\t\t\t\t}\n\t\t\t\t\tif (errorCode !== ERROR.OK.code && this.connectOptions.reconnect) {\n\t\t\t\t\t// Start automatic reconnect process for the very first time since last successful connect.\n\t\t\t\t\t\tthis._reconnectInterval = 1;\n\t\t\t\t\t\tthis._reconnect();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t// Otherwise we never had a connection, so indicate that the connect has failed.\n\t\t\t\t\tif (this.connectOptions.mqttVersion === 4 && this.connectOptions.mqttVersionExplicit === false) {\n\t\t\t\t\t\tthis._trace(\"Failed to connect V4, dropping back to V3\");\n\t\t\t\t\t\tthis.connectOptions.mqttVersion = 3;\n\t\t\t\t\t\tif (this.connectOptions.uris) {\n\t\t\t\t\t\t\tthis.hostIndex = 0;\n\t\t\t\t\t\t\tthis._doConnect(this.connectOptions.uris[0]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._doConnect(this.uri);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(this.connectOptions.onFailure) {\n\t\t\t\t\t\tthis.connectOptions.onFailure({invocationContext:this.connectOptions.invocationContext, errorCode:errorCode, errorMessage:errorText});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/** @ignore */\n\t\tClientImpl.prototype._trace = function () {\n\t\t// Pass trace message back to client's callback function\n\t\t\tif (this.traceFunction) {\n\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\tfor (var i in args)\n\t\t\t\t{\n\t\t\t\t\tif (typeof args[i] !== \"undefined\")\n\t\t\t\t\t\targs.splice(i, 1, JSON.stringify(args[i]));\n\t\t\t\t}\n\t\t\t\tvar record = args.join(\"\");\n\t\t\t\tthis.traceFunction ({severity: \"Debug\", message: record\t});\n\t\t\t}\n\n\t\t\t//buffer style trace\n\t\t\tif ( this._traceBuffer !== null ) {\n\t\t\t\tfor (var i = 0, max = arguments.length; i < max; i++) {\n\t\t\t\t\tif ( this._traceBuffer.length == this._MAX_TRACE_ENTRIES ) {\n\t\t\t\t\t\tthis._traceBuffer.shift();\n\t\t\t\t\t}\n\t\t\t\t\tif (i === 0) this._traceBuffer.push(arguments[i]);\n\t\t\t\t\telse if (typeof arguments[i] === \"undefined\" ) this._traceBuffer.push(arguments[i]);\n\t\t\t\t\telse this._traceBuffer.push(\"  \"+JSON.stringify(arguments[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/** @ignore */\n\t\tClientImpl.prototype._traceMask = function (traceObject, masked) {\n\t\t\tvar traceObjectMasked = {};\n\t\t\tfor (var attr in traceObject) {\n\t\t\t\tif (traceObject.hasOwnProperty(attr)) {\n\t\t\t\t\tif (attr == masked)\n\t\t\t\t\t\ttraceObjectMasked[attr] = \"******\";\n\t\t\t\t\telse\n\t\t\t\t\t\ttraceObjectMasked[attr] = traceObject[attr];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn traceObjectMasked;\n\t\t};\n\n\t\t// ------------------------------------------------------------------------\n\t\t// Public Programming interface.\n\t\t// ------------------------------------------------------------------------\n\n\t\t/**\n\t * The JavaScript application communicates to the server using a {@link Paho.Client} object.\n\t * <p>\n\t * Most applications will create just one Client object and then call its connect() method,\n\t * however applications can create more than one Client object if they wish.\n\t * In this case the combination of host, port and clientId attributes must be different for each Client object.\n\t * <p>\n\t * The send, subscribe and unsubscribe methods are implemented as asynchronous JavaScript methods\n\t * (even though the underlying protocol exchange might be synchronous in nature).\n\t * This means they signal their completion by calling back to the application,\n\t * via Success or Failure callback functions provided by the application on the method in question.\n\t * Such callbacks are called at most once per method invocation and do not persist beyond the lifetime\n\t * of the script that made the invocation.\n\t * <p>\n\t * In contrast there are some callback functions, most notably <i>onMessageArrived</i>,\n\t * that are defined on the {@link Paho.Client} object.\n\t * These may get called multiple times, and aren't directly related to specific method invocations made by the client.\n\t *\n\t * @name Paho.Client\n\t *\n\t * @constructor\n\t *\n\t * @param {string} host - the address of the messaging server, as a fully qualified WebSocket URI, as a DNS name or dotted decimal IP address.\n\t * @param {number} port - the port number to connect to - only required if host is not a URI\n\t * @param {string} path - the path on the host to connect to - only used if host is not a URI. Default: '/mqtt'.\n\t * @param {string} clientId - the Messaging client identifier, between 1 and 23 characters in length.\n\t *\n\t * @property {string} host - <i>read only</i> the server's DNS hostname or dotted decimal IP address.\n\t * @property {number} port - <i>read only</i> the server's port.\n\t * @property {string} path - <i>read only</i> the server's path.\n\t * @property {string} clientId - <i>read only</i> used when connecting to the server.\n\t * @property {function} onConnectionLost - called when a connection has been lost.\n\t *                            after a connect() method has succeeded.\n\t *                            Establish the call back used when a connection has been lost. The connection may be\n\t *                            lost because the client initiates a disconnect or because the server or network\n\t *                            cause the client to be disconnected. The disconnect call back may be called without\n\t *                            the connectionComplete call back being invoked if, for example the client fails to\n\t *                            connect.\n\t *                            A single response object parameter is passed to the onConnectionLost callback containing the following fields:\n\t *                            <ol>\n\t *                            <li>errorCode\n\t *                            <li>errorMessage\n\t *                            </ol>\n\t * @property {function} onMessageDelivered - called when a message has been delivered.\n\t *                            All processing that this Client will ever do has been completed. So, for example,\n\t *                            in the case of a Qos=2 message sent by this client, the PubComp flow has been received from the server\n\t *                            and the message has been removed from persistent storage before this callback is invoked.\n\t *                            Parameters passed to the onMessageDelivered callback are:\n\t *                            <ol>\n\t *                            <li>{@link Paho.Message} that was delivered.\n\t *                            </ol>\n\t * @property {function} onMessageArrived - called when a message has arrived in this Paho.client.\n\t *                            Parameters passed to the onMessageArrived callback are:\n\t *                            <ol>\n\t *                            <li>{@link Paho.Message} that has arrived.\n\t *                            </ol>\n\t * @property {function} onConnected - called when a connection is successfully made to the server.\n\t *                                  after a connect() method.\n\t *                                  Parameters passed to the onConnected callback are:\n\t *                                  <ol>\n\t *                                  <li>reconnect (boolean) - If true, the connection was the result of a reconnect.</li>\n\t *                                  <li>URI (string) - The URI used to connect to the server.</li>\n\t *                                  </ol>\n\t * @property {boolean} disconnectedPublishing - if set, will enable disconnected publishing in\n\t *                                            in the event that the connection to the server is lost.\n\t * @property {number} disconnectedBufferSize - Used to set the maximum number of messages that the disconnected\n\t *                                             buffer will hold before rejecting new messages. Default size: 5000 messages\n\t * @property {function} trace - called whenever trace is called. TODO\n\t */\n\t\tvar Client = function (host, port, path, clientId) {\n\n\t\t\tvar uri;\n\n\t\t\tif (typeof host !== \"string\")\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof host, \"host\"]));\n\n\t\t\tif (arguments.length == 2) {\n\t\t\t// host: must be full ws:// uri\n\t\t\t// port: clientId\n\t\t\t\tclientId = port;\n\t\t\t\turi = host;\n\t\t\t\tvar match = uri.match(/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/);\n\t\t\t\tif (match) {\n\t\t\t\t\thost = match[4]||match[2];\n\t\t\t\t\tport = parseInt(match[7]);\n\t\t\t\t\tpath = match[8];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT,[host,\"host\"]));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (arguments.length == 3) {\n\t\t\t\t\tclientId = path;\n\t\t\t\t\tpath = \"/mqtt\";\n\t\t\t\t}\n\t\t\t\tif (typeof port !== \"number\" || port < 0)\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof port, \"port\"]));\n\t\t\t\tif (typeof path !== \"string\")\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof path, \"path\"]));\n\n\t\t\t\tvar ipv6AddSBracket = (host.indexOf(\":\") !== -1 && host.slice(0,1) !== \"[\" && host.slice(-1) !== \"]\");\n\t\t\t\turi = \"ws://\"+(ipv6AddSBracket?\"[\"+host+\"]\":host)+\":\"+port+path;\n\t\t\t}\n\n\t\t\tvar clientIdLength = 0;\n\t\t\tfor (var i = 0; i<clientId.length; i++) {\n\t\t\t\tvar charCode = clientId.charCodeAt(i);\n\t\t\t\tif (0xD800 <= charCode && charCode <= 0xDBFF)  {\n\t\t\t\t\ti++; // Surrogate pair.\n\t\t\t\t}\n\t\t\t\tclientIdLength++;\n\t\t\t}\n\t\t\tif (typeof clientId !== \"string\" || clientIdLength > 65535)\n\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [clientId, \"clientId\"]));\n\n\t\t\tvar client = new ClientImpl(uri, host, port, path, clientId);\n\n\t\t\t//Public Properties\n\t\t\tObject.defineProperties(this,{\n\t\t\t\t\"host\":{\n\t\t\t\t\tget: function() { return host; },\n\t\t\t\t\tset: function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }\n\t\t\t\t},\n\t\t\t\t\"port\":{\n\t\t\t\t\tget: function() { return port; },\n\t\t\t\t\tset: function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }\n\t\t\t\t},\n\t\t\t\t\"path\":{\n\t\t\t\t\tget: function() { return path; },\n\t\t\t\t\tset: function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }\n\t\t\t\t},\n\t\t\t\t\"uri\":{\n\t\t\t\t\tget: function() { return uri; },\n\t\t\t\t\tset: function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }\n\t\t\t\t},\n\t\t\t\t\"clientId\":{\n\t\t\t\t\tget: function() { return client.clientId; },\n\t\t\t\t\tset: function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }\n\t\t\t\t},\n\t\t\t\t\"onConnected\":{\n\t\t\t\t\tget: function() { return client.onConnected; },\n\t\t\t\t\tset: function(newOnConnected) {\n\t\t\t\t\t\tif (typeof newOnConnected === \"function\")\n\t\t\t\t\t\t\tclient.onConnected = newOnConnected;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnected, \"onConnected\"]));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"disconnectedPublishing\":{\n\t\t\t\t\tget: function() { return client.disconnectedPublishing; },\n\t\t\t\t\tset: function(newDisconnectedPublishing) {\n\t\t\t\t\t\tclient.disconnectedPublishing = newDisconnectedPublishing;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"disconnectedBufferSize\":{\n\t\t\t\t\tget: function() { return client.disconnectedBufferSize; },\n\t\t\t\t\tset: function(newDisconnectedBufferSize) {\n\t\t\t\t\t\tclient.disconnectedBufferSize = newDisconnectedBufferSize;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"onConnectionLost\":{\n\t\t\t\t\tget: function() { return client.onConnectionLost; },\n\t\t\t\t\tset: function(newOnConnectionLost) {\n\t\t\t\t\t\tif (typeof newOnConnectionLost === \"function\")\n\t\t\t\t\t\t\tclient.onConnectionLost = newOnConnectionLost;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnectionLost, \"onConnectionLost\"]));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"onMessageDelivered\":{\n\t\t\t\t\tget: function() { return client.onMessageDelivered; },\n\t\t\t\t\tset: function(newOnMessageDelivered) {\n\t\t\t\t\t\tif (typeof newOnMessageDelivered === \"function\")\n\t\t\t\t\t\t\tclient.onMessageDelivered = newOnMessageDelivered;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageDelivered, \"onMessageDelivered\"]));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"onMessageArrived\":{\n\t\t\t\t\tget: function() { return client.onMessageArrived; },\n\t\t\t\t\tset: function(newOnMessageArrived) {\n\t\t\t\t\t\tif (typeof newOnMessageArrived === \"function\")\n\t\t\t\t\t\t\tclient.onMessageArrived = newOnMessageArrived;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageArrived, \"onMessageArrived\"]));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"trace\":{\n\t\t\t\t\tget: function() { return client.traceFunction; },\n\t\t\t\t\tset: function(trace) {\n\t\t\t\t\t\tif(typeof trace === \"function\"){\n\t\t\t\t\t\t\tclient.traceFunction = trace;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof trace, \"onTrace\"]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t/**\n\t\t * Connect this Messaging client to its server.\n\t\t *\n\t\t * @name Paho.Client#connect\n\t\t * @function\n\t\t * @param {object} connectOptions - Attributes used with the connection.\n\t\t * @param {number} connectOptions.timeout - If the connect has not succeeded within this\n\t\t *                    number of seconds, it is deemed to have failed.\n\t\t *                    The default is 30 seconds.\n\t\t * @param {string} connectOptions.userName - Authentication username for this connection.\n\t\t * @param {string} connectOptions.password - Authentication password for this connection.\n\t\t * @param {Paho.Message} connectOptions.willMessage - sent by the server when the client\n\t\t *                    disconnects abnormally.\n\t\t * @param {number} connectOptions.keepAliveInterval - the server disconnects this client if\n\t\t *                    there is no activity for this number of seconds.\n\t\t *                    The default value of 60 seconds is assumed if not set.\n\t\t * @param {boolean} connectOptions.cleanSession - if true(default) the client and server\n\t\t *                    persistent state is deleted on successful connect.\n\t\t * @param {boolean} connectOptions.useSSL - if present and true, use an SSL Websocket connection.\n\t\t * @param {object} connectOptions.invocationContext - passed to the onSuccess callback or onFailure callback.\n\t\t * @param {function} connectOptions.onSuccess - called when the connect acknowledgement\n\t\t *                    has been received from the server.\n\t\t * A single response object parameter is passed to the onSuccess callback containing the following fields:\n\t\t * <ol>\n\t\t * <li>invocationContext as passed in to the onSuccess method in the connectOptions.\n\t\t * </ol>\n\t * @param {function} connectOptions.onFailure - called when the connect request has failed or timed out.\n\t\t * A single response object parameter is passed to the onFailure callback containing the following fields:\n\t\t * <ol>\n\t\t * <li>invocationContext as passed in to the onFailure method in the connectOptions.\n\t\t * <li>errorCode a number indicating the nature of the error.\n\t\t * <li>errorMessage text describing the error.\n\t\t * </ol>\n\t * @param {array} connectOptions.hosts - If present this contains either a set of hostnames or fully qualified\n\t\t * WebSocket URIs (ws://iot.eclipse.org:80/ws), that are tried in order in place\n\t\t * of the host and port paramater on the construtor. The hosts are tried one at at time in order until\n\t\t * one of then succeeds.\n\t * @param {array} connectOptions.ports - If present the set of ports matching the hosts. If hosts contains URIs, this property\n\t\t * is not used.\n\t * @param {boolean} connectOptions.reconnect - Sets whether the client will automatically attempt to reconnect\n\t * to the server if the connection is lost.\n\t *<ul>\n\t *<li>If set to false, the client will not attempt to automatically reconnect to the server in the event that the\n\t * connection is lost.</li>\n\t *<li>If set to true, in the event that the connection is lost, the client will attempt to reconnect to the server.\n\t * It will initially wait 1 second before it attempts to reconnect, for every failed reconnect attempt, the delay\n\t * will double until it is at 2 minutes at which point the delay will stay at 2 minutes.</li>\n\t *</ul>\n\t * @param {number} connectOptions.mqttVersion - The version of MQTT to use to connect to the MQTT Broker.\n\t *<ul>\n\t *<li>3 - MQTT V3.1</li>\n\t *<li>4 - MQTT V3.1.1</li>\n\t *</ul>\n\t * @param {boolean} connectOptions.mqttVersionExplicit - If set to true, will force the connection to use the\n\t * selected MQTT Version or will fail to connect.\n\t * @param {array} connectOptions.uris - If present, should contain a list of fully qualified WebSocket uris\n\t * (e.g. ws://iot.eclipse.org:80/ws), that are tried in order in place of the host and port parameter of the construtor.\n\t * The uris are tried one at a time in order until one of them succeeds. Do not use this in conjunction with hosts as\n\t * the hosts array will be converted to uris and will overwrite this property.\n\t\t * @throws {InvalidState} If the client is not in disconnected state. The client must have received connectionLost\n\t\t * or disconnected before calling connect for a second or subsequent time.\n\t\t */\n\t\t\tthis.connect = function (connectOptions) {\n\t\t\t\tconnectOptions = connectOptions || {} ;\n\t\t\t\tvalidate(connectOptions,  {timeout:\"number\",\n\t\t\t\t\tuserName:\"string\",\n\t\t\t\t\tpassword:\"string\",\n\t\t\t\t\twillMessage:\"object\",\n\t\t\t\t\tkeepAliveInterval:\"number\",\n\t\t\t\t\tcleanSession:\"boolean\",\n\t\t\t\t\tuseSSL:\"boolean\",\n\t\t\t\t\tinvocationContext:\"object\",\n\t\t\t\t\tonSuccess:\"function\",\n\t\t\t\t\tonFailure:\"function\",\n\t\t\t\t\thosts:\"object\",\n\t\t\t\t\tports:\"object\",\n\t\t\t\t\treconnect:\"boolean\",\n\t\t\t\t\tmqttVersion:\"number\",\n\t\t\t\t\tmqttVersionExplicit:\"boolean\",\n\t\t\t\t\turis: \"object\"});\n\n\t\t\t\t// If no keep alive interval is set, assume 60 seconds.\n\t\t\t\tif (connectOptions.keepAliveInterval === undefined)\n\t\t\t\t\tconnectOptions.keepAliveInterval = 60;\n\n\t\t\t\tif (connectOptions.mqttVersion > 4 || connectOptions.mqttVersion < 3) {\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.mqttVersion, \"connectOptions.mqttVersion\"]));\n\t\t\t\t}\n\n\t\t\t\tif (connectOptions.mqttVersion === undefined) {\n\t\t\t\t\tconnectOptions.mqttVersionExplicit = false;\n\t\t\t\t\tconnectOptions.mqttVersion = 4;\n\t\t\t\t} else {\n\t\t\t\t\tconnectOptions.mqttVersionExplicit = true;\n\t\t\t\t}\n\n\t\t\t\t//Check that if password is set, so is username\n\t\t\t\tif (connectOptions.password !== undefined && connectOptions.userName === undefined)\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.password, \"connectOptions.password\"]));\n\n\t\t\t\tif (connectOptions.willMessage) {\n\t\t\t\t\tif (!(connectOptions.willMessage instanceof Message))\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [connectOptions.willMessage, \"connectOptions.willMessage\"]));\n\t\t\t\t\t// The will message must have a payload that can be represented as a string.\n\t\t\t\t\t// Cause the willMessage to throw an exception if this is not the case.\n\t\t\t\t\tconnectOptions.willMessage.stringPayload = null;\n\n\t\t\t\t\tif (typeof connectOptions.willMessage.destinationName === \"undefined\")\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.willMessage.destinationName, \"connectOptions.willMessage.destinationName\"]));\n\t\t\t\t}\n\t\t\t\tif (typeof connectOptions.cleanSession === \"undefined\")\n\t\t\t\t\tconnectOptions.cleanSession = true;\n\t\t\t\tif (connectOptions.hosts) {\n\n\t\t\t\t\tif (!(connectOptions.hosts instanceof Array) )\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\n\t\t\t\t\tif (connectOptions.hosts.length <1 )\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\n\n\t\t\t\t\tvar usingURIs = false;\n\t\t\t\t\tfor (var i = 0; i<connectOptions.hosts.length; i++) {\n\t\t\t\t\t\tif (typeof connectOptions.hosts[i] !== \"string\")\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.hosts[i], \"connectOptions.hosts[\"+i+\"]\"]));\n\t\t\t\t\t\tif (/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/.test(connectOptions.hosts[i])) {\n\t\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\t\tusingURIs = true;\n\t\t\t\t\t\t\t} else if (!usingURIs) {\n\t\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], \"connectOptions.hosts[\"+i+\"]\"]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (usingURIs) {\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], \"connectOptions.hosts[\"+i+\"]\"]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!usingURIs) {\n\t\t\t\t\t\tif (!connectOptions.ports)\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n\t\t\t\t\t\tif (!(connectOptions.ports instanceof Array) )\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n\t\t\t\t\t\tif (connectOptions.hosts.length !== connectOptions.ports.length)\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n\n\t\t\t\t\t\tconnectOptions.uris = [];\n\n\t\t\t\t\t\tfor (var i = 0; i<connectOptions.hosts.length; i++) {\n\t\t\t\t\t\t\tif (typeof connectOptions.ports[i] !== \"number\" || connectOptions.ports[i] < 0)\n\t\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.ports[i], \"connectOptions.ports[\"+i+\"]\"]));\n\t\t\t\t\t\t\tvar host = connectOptions.hosts[i];\n\t\t\t\t\t\t\tvar port = connectOptions.ports[i];\n\n\t\t\t\t\t\t\tvar ipv6 = (host.indexOf(\":\") !== -1);\n\t\t\t\t\t\t\turi = \"ws://\"+(ipv6?\"[\"+host+\"]\":host)+\":\"+port+path;\n\t\t\t\t\t\t\tconnectOptions.uris.push(uri);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconnectOptions.uris = connectOptions.hosts;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclient.connect(connectOptions);\n\t\t\t};\n\n\t\t\t/**\n\t\t * Subscribe for messages, request receipt of a copy of messages sent to the destinations described by the filter.\n\t\t *\n\t\t * @name Paho.Client#subscribe\n\t\t * @function\n\t\t * @param {string} filter describing the destinations to receive messages from.\n\t\t * <br>\n\t\t * @param {object} subscribeOptions - used to control the subscription\n\t\t *\n\t\t * @param {number} subscribeOptions.qos - the maximum qos of any publications sent\n\t\t *                                  as a result of making this subscription.\n\t\t * @param {object} subscribeOptions.invocationContext - passed to the onSuccess callback\n\t\t *                                  or onFailure callback.\n\t\t * @param {function} subscribeOptions.onSuccess - called when the subscribe acknowledgement\n\t\t *                                  has been received from the server.\n\t\t *                                  A single response object parameter is passed to the onSuccess callback containing the following fields:\n\t\t *                                  <ol>\n\t\t *                                  <li>invocationContext if set in the subscribeOptions.\n\t\t *                                  </ol>\n\t\t * @param {function} subscribeOptions.onFailure - called when the subscribe request has failed or timed out.\n\t\t *                                  A single response object parameter is passed to the onFailure callback containing the following fields:\n\t\t *                                  <ol>\n\t\t *                                  <li>invocationContext - if set in the subscribeOptions.\n\t\t *                                  <li>errorCode - a number indicating the nature of the error.\n\t\t *                                  <li>errorMessage - text describing the error.\n\t\t *                                  </ol>\n\t\t * @param {number} subscribeOptions.timeout - which, if present, determines the number of\n\t\t *                                  seconds after which the onFailure calback is called.\n\t\t *                                  The presence of a timeout does not prevent the onSuccess\n\t\t *                                  callback from being called when the subscribe completes.\n\t\t * @throws {InvalidState} if the client is not in connected state.\n\t\t */\n\t\t\tthis.subscribe = function (filter, subscribeOptions) {\n\t\t\t\tif (typeof filter !== \"string\" && filter.constructor !== Array)\n\t\t\t\t\tthrow new Error(\"Invalid argument:\"+filter);\n\t\t\t\tsubscribeOptions = subscribeOptions || {} ;\n\t\t\t\tvalidate(subscribeOptions,  {qos:\"number\",\n\t\t\t\t\tinvocationContext:\"object\",\n\t\t\t\t\tonSuccess:\"function\",\n\t\t\t\t\tonFailure:\"function\",\n\t\t\t\t\ttimeout:\"number\"\n\t\t\t\t});\n\t\t\t\tif (subscribeOptions.timeout && !subscribeOptions.onFailure)\n\t\t\t\t\tthrow new Error(\"subscribeOptions.timeout specified with no onFailure callback.\");\n\t\t\t\tif (typeof subscribeOptions.qos !== \"undefined\" && !(subscribeOptions.qos === 0 || subscribeOptions.qos === 1 || subscribeOptions.qos === 2 ))\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [subscribeOptions.qos, \"subscribeOptions.qos\"]));\n\t\t\t\tclient.subscribe(filter, subscribeOptions);\n\t\t\t};\n\n\t\t/**\n\t\t * Unsubscribe for messages, stop receiving messages sent to destinations described by the filter.\n\t\t *\n\t\t * @name Paho.Client#unsubscribe\n\t\t * @function\n\t\t * @param {string} filter - describing the destinations to receive messages from.\n\t\t * @param {object} unsubscribeOptions - used to control the subscription\n\t\t * @param {object} unsubscribeOptions.invocationContext - passed to the onSuccess callback\n\t\t\t\t\t\t\t\t\t\t\t  or onFailure callback.\n\t\t * @param {function} unsubscribeOptions.onSuccess - called when the unsubscribe acknowledgement has been received from the server.\n\t\t *                                    A single response object parameter is passed to the\n\t\t *                                    onSuccess callback containing the following fields:\n\t\t *                                    <ol>\n\t\t *                                    <li>invocationContext - if set in the unsubscribeOptions.\n\t\t *                                    </ol>\n\t\t * @param {function} unsubscribeOptions.onFailure called when the unsubscribe request has failed or timed out.\n\t\t *                                    A single response object parameter is passed to the onFailure callback containing the following fields:\n\t\t *                                    <ol>\n\t\t *                                    <li>invocationContext - if set in the unsubscribeOptions.\n\t\t *                                    <li>errorCode - a number indicating the nature of the error.\n\t\t *                                    <li>errorMessage - text describing the error.\n\t\t *                                    </ol>\n\t\t * @param {number} unsubscribeOptions.timeout - which, if present, determines the number of seconds\n\t\t *                                    after which the onFailure callback is called. The presence of\n\t\t *                                    a timeout does not prevent the onSuccess callback from being\n\t\t *                                    called when the unsubscribe completes\n\t\t * @throws {InvalidState} if the client is not in connected state.\n\t\t */\n\t\t\tthis.unsubscribe = function (filter, unsubscribeOptions) {\n\t\t\t\tif (typeof filter !== \"string\" && filter.constructor !== Array)\n\t\t\t\t\tthrow new Error(\"Invalid argument:\"+filter);\n\t\t\t\tunsubscribeOptions = unsubscribeOptions || {} ;\n\t\t\t\tvalidate(unsubscribeOptions,  {invocationContext:\"object\",\n\t\t\t\t\tonSuccess:\"function\",\n\t\t\t\t\tonFailure:\"function\",\n\t\t\t\t\ttimeout:\"number\"\n\t\t\t\t});\n\t\t\t\tif (unsubscribeOptions.timeout && !unsubscribeOptions.onFailure)\n\t\t\t\t\tthrow new Error(\"unsubscribeOptions.timeout specified with no onFailure callback.\");\n\t\t\t\tclient.unsubscribe(filter, unsubscribeOptions);\n\t\t\t};\n\n\t\t\t/**\n\t\t * Send a message to the consumers of the destination in the Message.\n\t\t *\n\t\t * @name Paho.Client#send\n\t\t * @function\n\t\t * @param {string|Paho.Message} topic - <b>mandatory</b> The name of the destination to which the message is to be sent.\n\t\t * \t\t\t\t\t   - If it is the only parameter, used as Paho.Message object.\n\t\t * @param {String|ArrayBuffer} payload - The message data to be sent.\n\t\t * @param {number} qos The Quality of Service used to deliver the message.\n\t\t * \t\t<dl>\n\t\t * \t\t\t<dt>0 Best effort (default).\n\t\t *     \t\t\t<dt>1 At least once.\n\t\t *     \t\t\t<dt>2 Exactly once.\n\t\t * \t\t</dl>\n\t\t * @param {Boolean} retained If true, the message is to be retained by the server and delivered\n\t\t *                     to both current and future subscriptions.\n\t\t *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\n\t\t *                     A received message has the retained boolean set to true if the message was published\n\t\t *                     with the retained boolean set to true\n\t\t *                     and the subscrption was made after the message has been published.\n\t\t * @throws {InvalidState} if the client is not connected.\n\t\t */\n\t\t\tthis.send = function (topic,payload,qos,retained) {\n\t\t\t\tvar message ;\n\n\t\t\t\tif(arguments.length === 0){\n\t\t\t\t\tthrow new Error(\"Invalid argument.\"+\"length\");\n\n\t\t\t\t}else if(arguments.length == 1) {\n\n\t\t\t\t\tif (!(topic instanceof Message) && (typeof topic !== \"string\"))\n\t\t\t\t\t\tthrow new Error(\"Invalid argument:\"+ typeof topic);\n\n\t\t\t\t\tmessage = topic;\n\t\t\t\t\tif (typeof message.destinationName === \"undefined\")\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT,[message.destinationName,\"Message.destinationName\"]));\n\t\t\t\t\tclient.send(message);\n\n\t\t\t\t}else {\n\t\t\t\t//parameter checking in Message object\n\t\t\t\t\tmessage = new Message(payload);\n\t\t\t\t\tmessage.destinationName = topic;\n\t\t\t\t\tif(arguments.length >= 3)\n\t\t\t\t\t\tmessage.qos = qos;\n\t\t\t\t\tif(arguments.length >= 4)\n\t\t\t\t\t\tmessage.retained = retained;\n\t\t\t\t\tclient.send(message);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t * Publish a message to the consumers of the destination in the Message.\n\t\t * Synonym for Paho.Mqtt.Client#send\n\t\t *\n\t\t * @name Paho.Client#publish\n\t\t * @function\n\t\t * @param {string|Paho.Message} topic - <b>mandatory</b> The name of the topic to which the message is to be published.\n\t\t * \t\t\t\t\t   - If it is the only parameter, used as Paho.Message object.\n\t\t * @param {String|ArrayBuffer} payload - The message data to be published.\n\t\t * @param {number} qos The Quality of Service used to deliver the message.\n\t\t * \t\t<dl>\n\t\t * \t\t\t<dt>0 Best effort (default).\n\t\t *     \t\t\t<dt>1 At least once.\n\t\t *     \t\t\t<dt>2 Exactly once.\n\t\t * \t\t</dl>\n\t\t * @param {Boolean} retained If true, the message is to be retained by the server and delivered\n\t\t *                     to both current and future subscriptions.\n\t\t *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\n\t\t *                     A received message has the retained boolean set to true if the message was published\n\t\t *                     with the retained boolean set to true\n\t\t *                     and the subscrption was made after the message has been published.\n\t\t * @throws {InvalidState} if the client is not connected.\n\t\t */\n\t\t\tthis.publish = function(topic,payload,qos,retained) {\n\t\t\t\tvar message ;\n\n\t\t\t\tif(arguments.length === 0){\n\t\t\t\t\tthrow new Error(\"Invalid argument.\"+\"length\");\n\n\t\t\t\t}else if(arguments.length == 1) {\n\n\t\t\t\t\tif (!(topic instanceof Message) && (typeof topic !== \"string\"))\n\t\t\t\t\t\tthrow new Error(\"Invalid argument:\"+ typeof topic);\n\n\t\t\t\t\tmessage = topic;\n\t\t\t\t\tif (typeof message.destinationName === \"undefined\")\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT,[message.destinationName,\"Message.destinationName\"]));\n\t\t\t\t\tclient.send(message);\n\n\t\t\t\t}else {\n\t\t\t\t\t//parameter checking in Message object\n\t\t\t\t\tmessage = new Message(payload);\n\t\t\t\t\tmessage.destinationName = topic;\n\t\t\t\t\tif(arguments.length >= 3)\n\t\t\t\t\t\tmessage.qos = qos;\n\t\t\t\t\tif(arguments.length >= 4)\n\t\t\t\t\t\tmessage.retained = retained;\n\t\t\t\t\tclient.send(message);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t * Normal disconnect of this Messaging client from its server.\n\t\t *\n\t\t * @name Paho.Client#disconnect\n\t\t * @function\n\t\t * @throws {InvalidState} if the client is already disconnected.\n\t\t */\n\t\t\tthis.disconnect = function () {\n\t\t\t\tclient.disconnect();\n\t\t\t};\n\n\t\t\t/**\n\t\t * Get the contents of the trace log.\n\t\t *\n\t\t * @name Paho.Client#getTraceLog\n\t\t * @function\n\t\t * @return {Object[]} tracebuffer containing the time ordered trace records.\n\t\t */\n\t\t\tthis.getTraceLog = function () {\n\t\t\t\treturn client.getTraceLog();\n\t\t\t};\n\n\t\t\t/**\n\t\t * Start tracing.\n\t\t *\n\t\t * @name Paho.Client#startTrace\n\t\t * @function\n\t\t */\n\t\t\tthis.startTrace = function () {\n\t\t\t\tclient.startTrace();\n\t\t\t};\n\n\t\t\t/**\n\t\t * Stop tracing.\n\t\t *\n\t\t * @name Paho.Client#stopTrace\n\t\t * @function\n\t\t */\n\t\t\tthis.stopTrace = function () {\n\t\t\t\tclient.stopTrace();\n\t\t\t};\n\n\t\t\tthis.isConnected = function() {\n\t\t\t\treturn client.connected;\n\t\t\t};\n\t\t};\n\n\t\t/**\n\t * An application message, sent or received.\n\t * <p>\n\t * All attributes may be null, which implies the default values.\n\t *\n\t * @name Paho.Message\n\t * @constructor\n\t * @param {String|ArrayBuffer} payload The message data to be sent.\n\t * <p>\n\t * @property {string} payloadString <i>read only</i> The payload as a string if the payload consists of valid UTF-8 characters.\n\t * @property {ArrayBuffer} payloadBytes <i>read only</i> The payload as an ArrayBuffer.\n\t * <p>\n\t * @property {string} destinationName <b>mandatory</b> The name of the destination to which the message is to be sent\n\t *                    (for messages about to be sent) or the name of the destination from which the message has been received.\n\t *                    (for messages received by the onMessage function).\n\t * <p>\n\t * @property {number} qos The Quality of Service used to deliver the message.\n\t * <dl>\n\t *     <dt>0 Best effort (default).\n\t *     <dt>1 At least once.\n\t *     <dt>2 Exactly once.\n\t * </dl>\n\t * <p>\n\t * @property {Boolean} retained If true, the message is to be retained by the server and delivered\n\t *                     to both current and future subscriptions.\n\t *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\n\t *                     A received message has the retained boolean set to true if the message was published\n\t *                     with the retained boolean set to true\n\t *                     and the subscrption was made after the message has been published.\n\t * <p>\n\t * @property {Boolean} duplicate <i>read only</i> If true, this message might be a duplicate of one which has already been received.\n\t *                     This is only set on messages received from the server.\n\t *\n\t */\n\t\tvar Message = function (newPayload) {\n\t\t\tvar payload;\n\t\t\tif (   typeof newPayload === \"string\" ||\n\t\tnewPayload instanceof ArrayBuffer ||\n\t\t(ArrayBuffer.isView(newPayload) && !(newPayload instanceof DataView))\n\t\t\t) {\n\t\t\t\tpayload = newPayload;\n\t\t\t} else {\n\t\t\t\tthrow (format(ERROR.INVALID_ARGUMENT, [newPayload, \"newPayload\"]));\n\t\t\t}\n\n\t\t\tvar destinationName;\n\t\t\tvar qos = 0;\n\t\t\tvar retained = false;\n\t\t\tvar duplicate = false;\n\n\t\t\tObject.defineProperties(this,{\n\t\t\t\t\"payloadString\":{\n\t\t\t\t\tenumerable : true,\n\t\t\t\t\tget : function () {\n\t\t\t\t\t\tif (typeof payload === \"string\")\n\t\t\t\t\t\t\treturn payload;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn parseUTF8(payload, 0, payload.length);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"payloadBytes\":{\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\tif (typeof payload === \"string\") {\n\t\t\t\t\t\t\tvar buffer = new ArrayBuffer(UTF8Length(payload));\n\t\t\t\t\t\t\tvar byteStream = new Uint8Array(buffer);\n\t\t\t\t\t\t\tstringToUTF8(payload, byteStream, 0);\n\n\t\t\t\t\t\t\treturn byteStream;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn payload;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"destinationName\":{\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function() { return destinationName; },\n\t\t\t\t\tset: function(newDestinationName) {\n\t\t\t\t\t\tif (typeof newDestinationName === \"string\")\n\t\t\t\t\t\t\tdestinationName = newDestinationName;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [newDestinationName, \"newDestinationName\"]));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"qos\":{\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function() { return qos; },\n\t\t\t\t\tset: function(newQos) {\n\t\t\t\t\t\tif (newQos === 0 || newQos === 1 || newQos === 2 )\n\t\t\t\t\t\t\tqos = newQos;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow new Error(\"Invalid argument:\"+newQos);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"retained\":{\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function() { return retained; },\n\t\t\t\t\tset: function(newRetained) {\n\t\t\t\t\t\tif (typeof newRetained === \"boolean\")\n\t\t\t\t\t\t\tretained = newRetained;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [newRetained, \"newRetained\"]));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"topic\":{\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function() { return destinationName; },\n\t\t\t\t\tset: function(newTopic) {destinationName=newTopic;}\n\t\t\t\t},\n\t\t\t\t\"duplicate\":{\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function() { return duplicate; },\n\t\t\t\t\tset: function(newDuplicate) {duplicate=newDuplicate;}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t// Module contents.\n\t\treturn {\n\t\t\tClient: Client,\n\t\t\tMessage: Message\n\t\t};\n\t// eslint-disable-next-line no-nested-ternary\n\t})(typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n\treturn PahoMQTT;\n});\n","/**\n * @fileoverview Paho mqtt client wrapper\n *\n */\nimport * as Paho from \"paho-mqtt\"; //https://www.npmjs.com/package/paho-mqtt\n\nvar _this;\n\n/**\n * Mqtt client wrapper class\n */\nexport default class MqttClient {\n  /**\n   * Create an mqtt client instance\n   * @param st an object with the client setting\n   */\n  constructor(st) {\n    // handle default this.settings\n    st = st || {};\n    this.settings = {\n      uri: st.uri !== undefined ? st.uri : \"wss://arena.andrew.cmu.edu/mqtt/\",\n      host: st.host !== undefined ? st.host : \"arena.andrew.cmu.edu\",\n      port: st.port !== undefined ? st.port : 8083,\n      path: st.path !== undefined ? st.path : \"/mqtt/\",\n      clientid:\n        st.clientid !== undefined\n          ? st.clientid\n          : \"this.mqttc-client-\" + Math.round(Math.random() * 10000),\n      subscribeTopics: st.subscribeTopics,\n      onConnectCallback: st.onConnectCallback,\n      onConnectCallbackContext: st.onConnectCallbackContext,\n      onMessageCallback: st.onMessageCallback,\n      willMessage:\n        st.willMessage !== undefined\n          ? new Paho.Message(st.willMessage)\n          : undefined,\n      dbg: st.dbg !== undefined ? st.dbg : false,\n      reconnect: st.reconnect !== undefined ? st.reconnect : true,\n      useSSL: st.useSSL !== undefined ? st.useSSL : true,\n    };\n\n    if (this.settings.willMessage !== undefined)\n      this.settings.willMessage.destinationName = st.willMessageTopic;\n\n    if (this.settings.dbg == true) console.log(this.settings);\n\n    _this = this;\n  }\n\n  async connect() {\n    if (this.settings.uri) {\n      if (this.settings.dbg == true) {\n        console.log(\"Connecting [uri]: \", this.settings.uri);\n        // init Paho client connection\n        this.mqttc = new Paho.Client(\n          this.settings.uri,\n          this.settings.clientid\n        );\n\n      }  \n    } else {\n      let wss = this.settings.useSSL == true ? \"wss://\": \"ws://\";\n      console.log(\"Connecting [host,port,path]: \" + wss + this.settings.host + \":\" + this.settings.port + this.settings.path);\n      // init Paho client connection\n      this.mqttc = new Paho.Client(\n        this.settings.host,\n        Number(this.settings.port),\n        this.settings.path,\n        this.settings.clientid\n      );\n    } \n\n    // callback handlers\n    this.mqttc.onConnectionLost = this.onConnectionLost.bind(this);\n    this.mqttc.onMessageArrived = this.onMessageArrived.bind(this);\n\n    let _this = this;\n    return new Promise(function (resolve, reject) {\n      // connect the client, if successful, call onConnect function\n      _this.mqttc.connect({\n        onSuccess: () => {\n          if (_this.settings.subscribeTopics != undefined) {\n            // Subscribe to the requested topic\n            if (_this.settings.subscribeTopics.length > 0) {\n              if (_this.settings.dbg == true)\n                console.log(\n                  \"Subscribing to: \" + _this.settings.subscribeTopics + \"\\n\"\n                );\n              _this.mqttc.subscribe(_this.settings.subscribeTopics);\n            }\n          }\n          if (_this.settings.onConnectCallback != undefined)\n            _this.settings.onConnectCallback(\n              _this.settings.onConnectCallbackContext\n            );\n          resolve();\n        },\n        onFailure: () => { throw new Error(\"Could not connect!\"); },\n        willMessage: _this.settings.willMessage,\n        reconnect: _this.settings.reconnect,\n        useSSL: _this.settings.useSSL\n      });\n    });\n  }\n\n  // message publication to self (invoke onMessageCallback directly)\n  directMesssage(topic, payload) {\n    if (typeof payload !== \"string\") payload = JSON.stringify(payload);\n    let msg = new Paho.Message(payload);\n    msg.destinationName = topic;\n    _this.settings.onMessageCallback(msg);\n  }\n\n  disconnect() {\n    try {\n      this.mqttc.disconnect();\n    } catch (err) {\n      if (this.settings.dbg == true) console.log(\"MQTT Disconnected.\");\n    }\n  }\n\n  reConnect() {\n    try {\n      this.mqttc.disconnect();\n    } catch (err) {\n      if (this.settings.dbg == true) console.log(\"MQTT Disconnected.\");\n    }\n    clientConnect();\n  }\n\n  /**\n   * Callback; Called when the client loses its connection\n   */\n  onConnectionLost(responseObject) {\n    if (this.settings.dbg == true) console.log(\"Mqtt client disconnected...\");\n\n    if (responseObject.errorCode !== 0) {\n      if (this.settings.dbg == true)\n        console.log(\"Mqtt ERROR: \" + responseObject.errorMessage + \"\\n\");\n    }\n  }\n\n  /**\n   * Callback; Called when a message arrives\n   */\n  onMessageArrived(message) {\n    if (this.settings.dbg == true)\n      console.log(\n        \"Mqtt Msg [\" +\n          message.destinationName +\n          \"]: \" +\n          message.payloadString +\n          \"\\n\"\n      );\n\n    if (this.settings.onMessageCallback != undefined)\n      this.settings.onMessageCallback(message);\n  }\n\n  publish(topic, payload) {\n    if (typeof payload !== \"string\") payload = JSON.stringify(payload);\n    if (this.settings.dbg == true)\n      console.log(\"Publishing (\" + topic + \"):\" + payload);\n    this.mqttc.send(topic, payload, 0, false);\n  }\n\n  subscribe(topic) {\n    if (this.settings.dbg == true) console.log(\"Subscribing :\" + topic);\n    this.mqttc.subscribe(topic);\n  }\n\n  unsubscribe(topic) {\n    console.log(\"Unsubscribing :\" + topic);\n    this.mqttc.unsubscribe(topic);\n  }\n}\n\nexports.MqttClient = MqttClient;","export var msgType = {\n    start: 0,\n    stop:1,\n    pub_msg: 2,\n    sub_msg: 3,\n    new_stream: 4,\n    signal: 5,\n    finish: 6\n}\n","/**\n * @fileoverview Thread-safe circular buffer (using SharedArrayBuffer for shared memory between workers) \n *\n * Copyright (C) Wiselab CMU.\n * @date April, 2020\n */\n\n const DFT_BUFFER_SIZE = 2048; // 2 Kb buffer \n\nexport default class SharedArrayCircularBuffer {\n  /**\n   * Create a SharedArrayBuffer instance of the needed size to store a circular buffer with byteSize bytes\n   *\n   * a circular buffer holds the following data:\n   *   uint32[0]: head index of the circular buffer\n   *   uint32[1]: tail index of the circular buffer\n   *   uint32[2]: total bytes allocated (byteSize)\n   *   uint32[3]: current number of bytes stored\n   *   uint8: spinlock flag\n   *   uint8[byteSize]: the circular buffer data\n   *\n   * @param byteSize size of the circular buffer\n   */\n  static createSharedBuffer(byteSize=DFT_BUFFER_SIZE) {\n    let buffer = new SharedArrayBuffer(\n      Uint32Array.BYTES_PER_ELEMENT * 4 + 1 + byteSize\n    );\n\n    // create views to the SharedArrayBuffer\n    let uint32 = new Uint32Array(buffer, 0, 4); // view for head, tail, byteSize and current number of bytes stored\n    let spinlock = new Uint8Array(buffer, Uint32Array.BYTES_PER_ELEMENT * 4, 1); // view to the spinlock flag\n\n    // init head, tail, allocated size and current number of bytes stored\n    uint32[0] = 0; // head (push to head)\n    uint32[1] = 0; // tail (pop from tail)\n    uint32[2] = byteSize; // total size allocated for the buffer data\n    uint32[3] = 0; // current number of bytes stored\n\n    spinlock[0] = 0;\n    return buffer;\n  }\n\n  /**\n   * Create an instance\n   * @param buffer SharedArrayBuffer instance where the circular buffer data is stored (created with createSharedBuffer())\n   * @param desc A string description of the buffer\n   */\n  constructor(buffer, desc) {\n    if (buffer == undefined)\n      throw new Error(\"Must provide a SharedArrayBuffer instance\");\n\n    // use the shared buffer for a structure that holds the circular buffer data:\n    //    uint32[0]: head index of the circular buffer\n    //    uint32[1]: tail index of the circular buffer\n    //    uint32[2]: total bytes allocated (byteSize)\n    //    uint32[3]: current number of bytes stored\n    //    uint8: spinlock flag\n    //    uint8[byteSize]: the circular buffer data\n    this.buffer = buffer; // previously created shared array buffer\n\n    let byteSize = buffer.byteLength - (Uint32Array.BYTES_PER_ELEMENT * 4 + 1);\n    //console.log(buffer);\n\n    // create views to the SharedArrayBuffer\n    this.uint32 = new Uint32Array(this.buffer, 0, 4); // view for head, tail, byteSize and current number of bytes stored\n    this.spinlock = new Uint8Array(this.buffer, Uint32Array.BYTES_PER_ELEMENT * 4, 1); // view to the spinlock flag\n    this.bytes = new Uint8Array(this.buffer, Uint32Array.BYTES_PER_ELEMENT * 4 + 1, byteSize); // view to the bytes stored\n\n    // flag to log when a push causes data to be overwritten (useful to check is buffer is too small)\n    this.logOverwrite = true;\n\n    this.desc = desc;\n  }\n\n  /**\n   * Pop bytes from tail, wrapping arround; stop when empty (tail = head)\n   * @param nbytes how many bytes to return\n   * @return an array of min(nbytes, buffer length) bytes; returns an empty array if buffer is empty (tail = head)\n   */\n  pop(nbytes) {\n    var data = [];\n\n    // acquire lock\n    while (Atomics.compareExchange(this.spinlock, 0, 0, 1) != 0);\n\n    nbytes = Math.min(nbytes, this.uint32[3]);\n    if (nbytes > 0) {\n      for (var i = 0; i < nbytes; i++) {\n        data[i] = this.bytes[(this.uint32[1] + i) % this.uint32[2]];\n      }\n      this.uint32[1] = (this.uint32[1] + i) % this.uint32[2];\n\n      this.uint32[3] -= nbytes;\n    }\n    // release lock\n    this.spinlock[0] = 0;\n\n    return data; // returns an empty array if there are no bytes to return\n  }\n\n  /**\n   * Push bytes to head, wrapping around and overwritting old vales\n   * @param bytes byte array\n   */\n  push(bytes) {\n    var i = 0;\n\n    if (this.buffer === undefined)\n      throw new Error(\"Must create a shared array instance\");\n    if (this.uint32[2] == 0)\n      throw new Error(\"Must create a shared array instance with size >0\");\n\n    // acquire lock\n    while (Atomics.compareExchange(this.spinlock, 0, 0, 1) != 0);\n\n    // push items\n    for (var i = 0; i < bytes.length; i++) {\n      let ii = (this.uint32[0] + i) % this.uint32[2];\n      this.bytes[ii] = bytes[i];\n    }\n\n    // update head\n    this.uint32[0] = (this.uint32[0] + i) % this.uint32[2];\n\n    // update tail, if needed\n    if (bytes.length > this.uint32[2] - this.uint32[3]) {\n      this.uint32[1] = this.uint32[0];\n      if (this.logOverwrite == true) console.log(\"Circular buffer overwrite:\", this.desc);\n    }\n\n    // update len\n    this.uint32[3] += bytes.length;\n    if (this.uint32[3] > this.uint32[2]) this.uint32[3] = this.uint32[2];\n\n    // release lock\n    this.spinlock[0] = 0;\n\n    return this.uint32[3];\n  }\n\n  /**\n   * Return number of bytes currently in the buffer\n   */\n  length() {\n    return this.uint32[3];\n  }\n\n  /**\n   * Return total bytes allocated for the buffer\n   */\n  size() {\n    return this.uint32[2];\n  }\n\n  /**\n   * Turn on/off the logging of when old values are overwritten\n   * @param value true/false\n   */\n  setOverwriteLog(value) {\n    this.logOverwrite = value;\n  }\n\n}\n","/**\n * @fileoverview Worker to publish (stdin/stderr) to mqtt topics and writes messages received on stdin topic to a shared buffer\n *\n * We start an mqtt client per module so that each module is visible to the mqtt server\n *\n * Copyright (C) Wiselab CMU.\n * @date April, 2020\n */\nimport MqttClient from \"/mqtt-client.js\";\nimport * as WorkerMessages from \"/worker-msgs.js\";\nimport * as ARTSMessages from \"/arts-msgs.js\";\nimport SharedArrayCircularBuffer from \"/sa-cbuffer.js\";\n\nconst stdin_topic_prefix = \"realm/proc/debug/stdin/\";\n\n// dictionary of shared buffers\nvar cb = [];\n\n// dictionary of mqtt clients\nvar mc = [];\n\n// dictionary with info about the modules\nvar mod = [];\n\nonmessage = async function (e) {\n\n  if (e.data.type == WorkerMessages.msgType.start) {\n    let modData = e.data.arts_mod_instance_data;\n\n    // object to store module info\n    mod[modData.uuid] = { };\n\n    // start mqtt client and subscribe to stdin topic\n    // (one per module; this way the server can distinguish the module traffic)\n    mod[modData.uuid].mc = new MqttClient({\n      clientid: modData.uuid, // mqtt client id is the module uuid\n      willMessageTopic: modData.reg_topic,\n      willMessage: JSON.stringify(ARTSMessages.mod(modData, ARTSMessages.Action.delete)),\n      subscribeTopics: [modData.stdin_topic], // subscribe to stdin topic\n      onMessageCallback: onMqttMessage.bind(null, modData.uuid),\n      dbg: false,\n    });\n\n    await mod[modData.uuid].mc.connect();\n\n    // create circular buffer from previously created shared array buffer (for stdin)\n    mod[modData.uuid].cb=[];\n    mod[modData.uuid].cb[modData.stdin_topic] = new SharedArrayCircularBuffer(e.data.shared_array_buffer, modData.stdin_topic);\n\n    // listen for messages on worker port\n    mod[modData.uuid].worker_port = e.data.worker_port;\n    \n    // set event handler to receive messages from the worker; (when the module finishes)\n    //mod[modData.uuid].worker_port.addEventListener('message', onmessage);\n    mod[modData.uuid].worker_port.onmessage = onmessage;\n    //this.worker_port.onmessage = onmessage;\n    return;\n  }\n\n  if (e.data.type == WorkerMessages.msgType.pub_msg) {\n    //console.log(\"publish:\", e.data.msg, \"->\", e.data.dst);\n    let modUuid = e.data.mod_uuid;\n    if (mod[modUuid] === undefined) return; // TODO: save messages sent after signal \n    mod[modUuid].mc.publish(e.data.dst, e.data.msg);\n    return;\n  }\n  if (e.data.type == WorkerMessages.msgType.new_stream) {\n\n    let modUuid = e.data.mod_uuid;\n        \n    if (e.data.channel.type === \"pubsub\") {\n\n      // create circular buffer from previously created shared array buffer\n      mod[modUuid].cb[e.data.channel.params.topic] = new SharedArrayCircularBuffer(e.data.shared_array_buffer, e.data.path+'/data');\n\n      // subscribe to topic\n      mod[modUuid].mc.subscribe(e.data.channel.params.topic);\n    } else if (e.data.channel.type === \"signalfd\") {\n\n      // create circular buffer from previously created shared array buffer\n      mod[modUuid].cb[\"signalfd\"] = new SharedArrayCircularBuffer(e.data.shared_array_buffer, \"signalfd\");\n      \n    } else {\n      // todo\n      console.log(e.data.channel.type, \": Channel type not implemented.\")\n    }\n\n    return;\n  }\n\n  if (e.data.type == WorkerMessages.msgType.signal) {\n    let modUuid = e.data.mod_uuid;\n\n    console.log(\"sending signal\");\n    // signalfd_siginfo struct is 128 bytes\n    let bytes = new Uint8Array(128);\n    bytes[0] = e.data.signo; // set the first byte (ssi_signo) indicating the signal number\n\n    if (mod[modUuid].cb[\"signalfd\"] === undefined) {\n      console.log(\"WASM module must open signalfd.\");\n      return;\n    }\n    mod[modUuid].cb[\"signalfd\"].push(bytes);\n  \n    // disconnect mqtt client\n    mod[modUuid].mc.disconnect();\n\n    // free data about this module\n    delete mod[modUuid];\n\n    return;\n  }\n\n};\n\nfunction onMqttMessage(modUuid, message) {\n  //console.log (\"IO worker received: \" + message.payloadString , message.destinationName);\n\n  // convert received message to a byte array and push to shared buffer\n  let bytes = new TextEncoder().encode(message.payloadString + \"\\n\");\n  mod[modUuid].cb[message.destinationName].push(bytes);\n}"]}